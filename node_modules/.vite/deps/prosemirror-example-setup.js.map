{
  "version": 3,
  "sources": ["../../w3c-keyname/index.js", "../../prosemirror-keymap/dist/index.js", "../../rope-sequence/dist/index.js", "../../prosemirror-history/dist/index.js", "../../prosemirror-commands/dist/index.js", "../../prosemirror-dropcursor/dist/index.js", "../../prosemirror-gapcursor/dist/index.js", "../../crelt/index.js", "../../prosemirror-menu/dist/index.js", "../../prosemirror-inputrules/dist/index.js", "../../prosemirror-example-setup/dist/index.js"],
  "sourcesContent": ["export var base = {\n  8: \"Backspace\",\n  9: \"Tab\",\n  10: \"Enter\",\n  12: \"NumLock\",\n  13: \"Enter\",\n  16: \"Shift\",\n  17: \"Control\",\n  18: \"Alt\",\n  20: \"CapsLock\",\n  27: \"Escape\",\n  32: \" \",\n  33: \"PageUp\",\n  34: \"PageDown\",\n  35: \"End\",\n  36: \"Home\",\n  37: \"ArrowLeft\",\n  38: \"ArrowUp\",\n  39: \"ArrowRight\",\n  40: \"ArrowDown\",\n  44: \"PrintScreen\",\n  45: \"Insert\",\n  46: \"Delete\",\n  59: \";\",\n  61: \"=\",\n  91: \"Meta\",\n  92: \"Meta\",\n  106: \"*\",\n  107: \"+\",\n  108: \",\",\n  109: \"-\",\n  110: \".\",\n  111: \"/\",\n  144: \"NumLock\",\n  145: \"ScrollLock\",\n  160: \"Shift\",\n  161: \"Shift\",\n  162: \"Control\",\n  163: \"Control\",\n  164: \"Alt\",\n  165: \"Alt\",\n  173: \"-\",\n  186: \";\",\n  187: \"=\",\n  188: \",\",\n  189: \"-\",\n  190: \".\",\n  191: \"/\",\n  192: \"`\",\n  219: \"[\",\n  220: \"\\\\\",\n  221: \"]\",\n  222: \"'\"\n}\n\nexport var shift = {\n  48: \")\",\n  49: \"!\",\n  50: \"@\",\n  51: \"#\",\n  52: \"$\",\n  53: \"%\",\n  54: \"^\",\n  55: \"&\",\n  56: \"*\",\n  57: \"(\",\n  59: \":\",\n  61: \"+\",\n  173: \"_\",\n  186: \":\",\n  187: \"+\",\n  188: \"<\",\n  189: \"_\",\n  190: \">\",\n  191: \"?\",\n  192: \"~\",\n  219: \"{\",\n  220: \"|\",\n  221: \"}\",\n  222: \"\\\"\"\n}\n\nvar mac = typeof navigator != \"undefined\" && /Mac/.test(navigator.platform)\nvar ie = typeof navigator != \"undefined\" && /MSIE \\d|Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(navigator.userAgent)\n\n// Fill in the digit keys\nfor (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i)\n\n// The function keys\nfor (var i = 1; i <= 24; i++) base[i + 111] = \"F\" + i\n\n// And the alphabetic keys\nfor (var i = 65; i <= 90; i++) {\n  base[i] = String.fromCharCode(i + 32)\n  shift[i] = String.fromCharCode(i)\n}\n\n// For each code that doesn't have a shift-equivalent, copy the base name\nfor (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code]\n\nexport function keyName(event) {\n  // On macOS, keys held with Shift and Cmd don't reflect the effect of Shift in `.key`.\n  // On IE, shift effect is never included in `.key`.\n  var ignoreKey = mac && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey ||\n      ie && event.shiftKey && event.key && event.key.length == 1 ||\n      event.key == \"Unidentified\"\n  var name = (!ignoreKey && event.key) ||\n    (event.shiftKey ? shift : base)[event.keyCode] ||\n    event.key || \"Unidentified\"\n  // Edge sometimes produces wrong names (Issue #3)\n  if (name == \"Esc\") name = \"Escape\"\n  if (name == \"Del\") name = \"Delete\"\n  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/\n  if (name == \"Left\") name = \"ArrowLeft\"\n  if (name == \"Up\") name = \"ArrowUp\"\n  if (name == \"Right\") name = \"ArrowRight\"\n  if (name == \"Down\") name = \"ArrowDown\"\n  return name\n}\n", "import { keyName, base } from 'w3c-keyname';\nimport { Plugin } from 'prosemirror-state';\n\nconst mac = typeof navigator != \"undefined\" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;\nfunction normalizeKeyName(name) {\n    let parts = name.split(/-(?!$)/), result = parts[parts.length - 1];\n    if (result == \"Space\")\n        result = \" \";\n    let alt, ctrl, shift, meta;\n    for (let i = 0; i < parts.length - 1; i++) {\n        let mod = parts[i];\n        if (/^(cmd|meta|m)$/i.test(mod))\n            meta = true;\n        else if (/^a(lt)?$/i.test(mod))\n            alt = true;\n        else if (/^(c|ctrl|control)$/i.test(mod))\n            ctrl = true;\n        else if (/^s(hift)?$/i.test(mod))\n            shift = true;\n        else if (/^mod$/i.test(mod)) {\n            if (mac)\n                meta = true;\n            else\n                ctrl = true;\n        }\n        else\n            throw new Error(\"Unrecognized modifier name: \" + mod);\n    }\n    if (alt)\n        result = \"Alt-\" + result;\n    if (ctrl)\n        result = \"Ctrl-\" + result;\n    if (meta)\n        result = \"Meta-\" + result;\n    if (shift)\n        result = \"Shift-\" + result;\n    return result;\n}\nfunction normalize(map) {\n    let copy = Object.create(null);\n    for (let prop in map)\n        copy[normalizeKeyName(prop)] = map[prop];\n    return copy;\n}\nfunction modifiers(name, event, shift = true) {\n    if (event.altKey)\n        name = \"Alt-\" + name;\n    if (event.ctrlKey)\n        name = \"Ctrl-\" + name;\n    if (event.metaKey)\n        name = \"Meta-\" + name;\n    if (shift && event.shiftKey)\n        name = \"Shift-\" + name;\n    return name;\n}\n/**\nCreate a keymap plugin for the given set of bindings.\n\nBindings should map key names to [command](https://prosemirror.net/docs/ref/#commands)-style\nfunctions, which will be called with `(EditorState, dispatch,\nEditorView)` arguments, and should return true when they've handled\nthe key. Note that the view argument isn't part of the command\nprotocol, but can be used as an escape hatch if a binding needs to\ndirectly interact with the UI.\n\nKey names may be strings like `\"Shift-Ctrl-Enter\"`—a key\nidentifier prefixed with zero or more modifiers. Key identifiers\nare based on the strings that can appear in\n[`KeyEvent.key`](https:developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key).\nUse lowercase letters to refer to letter keys (or uppercase letters\nif you want shift to be held). You may use `\"Space\"` as an alias\nfor the `\" \"` name.\n\nModifiers can be given in any order. `Shift-` (or `s-`), `Alt-` (or\n`a-`), `Ctrl-` (or `c-` or `Control-`) and `Cmd-` (or `m-` or\n`Meta-`) are recognized. For characters that are created by holding\nshift, the `Shift-` prefix is implied, and should not be added\nexplicitly.\n\nYou can use `Mod-` as a shorthand for `Cmd-` on Mac and `Ctrl-` on\nother platforms.\n\nYou can add multiple keymap plugins to an editor. The order in\nwhich they appear determines their precedence (the ones early in\nthe array get to dispatch first).\n*/\nfunction keymap(bindings) {\n    return new Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });\n}\n/**\nGiven a set of bindings (using the same format as\n[`keymap`](https://prosemirror.net/docs/ref/#keymap.keymap)), return a [keydown\nhandler](https://prosemirror.net/docs/ref/#view.EditorProps.handleKeyDown) that handles them.\n*/\nfunction keydownHandler(bindings) {\n    let map = normalize(bindings);\n    return function (view, event) {\n        let name = keyName(event), baseName, direct = map[modifiers(name, event)];\n        if (direct && direct(view.state, view.dispatch, view))\n            return true;\n        // A character key\n        if (name.length == 1 && name != \" \") {\n            if (event.shiftKey) {\n                // In case the name was already modified by shift, try looking\n                // it up without its shift modifier\n                let noShift = map[modifiers(name, event, false)];\n                if (noShift && noShift(view.state, view.dispatch, view))\n                    return true;\n            }\n            if ((event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) &&\n                (baseName = base[event.keyCode]) && baseName != name) {\n                // Try falling back to the keyCode when there's a modifier\n                // active or the character produced isn't ASCII, and our table\n                // produces a different name from the the keyCode. See #668,\n                // #1060\n                let fromCode = map[modifiers(baseName, event)];\n                if (fromCode && fromCode(view.state, view.dispatch, view))\n                    return true;\n            }\n        }\n        return false;\n    };\n}\n\nexport { keydownHandler, keymap };\n", "var GOOD_LEAF_SIZE = 200;\n\n// :: class<T> A rope sequence is a persistent sequence data structure\n// that supports appending, prepending, and slicing without doing a\n// full copy. It is represented as a mostly-balanced tree.\nvar RopeSequence = function RopeSequence () {};\n\nRopeSequence.prototype.append = function append (other) {\n  if (!other.length) { return this }\n  other = RopeSequence.from(other);\n\n  return (!this.length && other) ||\n    (other.length < GOOD_LEAF_SIZE && this.leafAppend(other)) ||\n    (this.length < GOOD_LEAF_SIZE && other.leafPrepend(this)) ||\n    this.appendInner(other)\n};\n\n// :: (union<[T], RopeSequence<T>>) → RopeSequence<T>\n// Prepend an array or other rope to this one, returning a new rope.\nRopeSequence.prototype.prepend = function prepend (other) {\n  if (!other.length) { return this }\n  return RopeSequence.from(other).append(this)\n};\n\nRopeSequence.prototype.appendInner = function appendInner (other) {\n  return new Append(this, other)\n};\n\n// :: (?number, ?number) → RopeSequence<T>\n// Create a rope repesenting a sub-sequence of this rope.\nRopeSequence.prototype.slice = function slice (from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  if (from >= to) { return RopeSequence.empty }\n  return this.sliceInner(Math.max(0, from), Math.min(this.length, to))\n};\n\n// :: (number) → T\n// Retrieve the element at the given position from this rope.\nRopeSequence.prototype.get = function get (i) {\n  if (i < 0 || i >= this.length) { return undefined }\n  return this.getInner(i)\n};\n\n// :: ((element: T, index: number) → ?bool, ?number, ?number)\n// Call the given function for each element between the given\n// indices. This tends to be more efficient than looping over the\n// indices and calling `get`, because it doesn't have to descend the\n// tree for every element.\nRopeSequence.prototype.forEach = function forEach (f, from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  if (from <= to)\n    { this.forEachInner(f, from, to, 0); }\n  else\n    { this.forEachInvertedInner(f, from, to, 0); }\n};\n\n// :: ((element: T, index: number) → U, ?number, ?number) → [U]\n// Map the given functions over the elements of the rope, producing\n// a flat array.\nRopeSequence.prototype.map = function map (f, from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  var result = [];\n  this.forEach(function (elt, i) { return result.push(f(elt, i)); }, from, to);\n  return result\n};\n\n// :: (?union<[T], RopeSequence<T>>) → RopeSequence<T>\n// Create a rope representing the given array, or return the rope\n// itself if a rope was given.\nRopeSequence.from = function from (values) {\n  if (values instanceof RopeSequence) { return values }\n  return values && values.length ? new Leaf(values) : RopeSequence.empty\n};\n\nvar Leaf = /*@__PURE__*/(function (RopeSequence) {\n  function Leaf(values) {\n    RopeSequence.call(this);\n    this.values = values;\n  }\n\n  if ( RopeSequence ) Leaf.__proto__ = RopeSequence;\n  Leaf.prototype = Object.create( RopeSequence && RopeSequence.prototype );\n  Leaf.prototype.constructor = Leaf;\n\n  var prototypeAccessors = { length: { configurable: true },depth: { configurable: true } };\n\n  Leaf.prototype.flatten = function flatten () {\n    return this.values\n  };\n\n  Leaf.prototype.sliceInner = function sliceInner (from, to) {\n    if (from == 0 && to == this.length) { return this }\n    return new Leaf(this.values.slice(from, to))\n  };\n\n  Leaf.prototype.getInner = function getInner (i) {\n    return this.values[i]\n  };\n\n  Leaf.prototype.forEachInner = function forEachInner (f, from, to, start) {\n    for (var i = from; i < to; i++)\n      { if (f(this.values[i], start + i) === false) { return false } }\n  };\n\n  Leaf.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {\n    for (var i = from - 1; i >= to; i--)\n      { if (f(this.values[i], start + i) === false) { return false } }\n  };\n\n  Leaf.prototype.leafAppend = function leafAppend (other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE)\n      { return new Leaf(this.values.concat(other.flatten())) }\n  };\n\n  Leaf.prototype.leafPrepend = function leafPrepend (other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE)\n      { return new Leaf(other.flatten().concat(this.values)) }\n  };\n\n  prototypeAccessors.length.get = function () { return this.values.length };\n\n  prototypeAccessors.depth.get = function () { return 0 };\n\n  Object.defineProperties( Leaf.prototype, prototypeAccessors );\n\n  return Leaf;\n}(RopeSequence));\n\n// :: RopeSequence\n// The empty rope sequence.\nRopeSequence.empty = new Leaf([]);\n\nvar Append = /*@__PURE__*/(function (RopeSequence) {\n  function Append(left, right) {\n    RopeSequence.call(this);\n    this.left = left;\n    this.right = right;\n    this.length = left.length + right.length;\n    this.depth = Math.max(left.depth, right.depth) + 1;\n  }\n\n  if ( RopeSequence ) Append.__proto__ = RopeSequence;\n  Append.prototype = Object.create( RopeSequence && RopeSequence.prototype );\n  Append.prototype.constructor = Append;\n\n  Append.prototype.flatten = function flatten () {\n    return this.left.flatten().concat(this.right.flatten())\n  };\n\n  Append.prototype.getInner = function getInner (i) {\n    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length)\n  };\n\n  Append.prototype.forEachInner = function forEachInner (f, from, to, start) {\n    var leftLen = this.left.length;\n    if (from < leftLen &&\n        this.left.forEachInner(f, from, Math.min(to, leftLen), start) === false)\n      { return false }\n    if (to > leftLen &&\n        this.right.forEachInner(f, Math.max(from - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false)\n      { return false }\n  };\n\n  Append.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {\n    var leftLen = this.left.length;\n    if (from > leftLen &&\n        this.right.forEachInvertedInner(f, from - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false)\n      { return false }\n    if (to < leftLen &&\n        this.left.forEachInvertedInner(f, Math.min(from, leftLen), to, start) === false)\n      { return false }\n  };\n\n  Append.prototype.sliceInner = function sliceInner (from, to) {\n    if (from == 0 && to == this.length) { return this }\n    var leftLen = this.left.length;\n    if (to <= leftLen) { return this.left.slice(from, to) }\n    if (from >= leftLen) { return this.right.slice(from - leftLen, to - leftLen) }\n    return this.left.slice(from, leftLen).append(this.right.slice(0, to - leftLen))\n  };\n\n  Append.prototype.leafAppend = function leafAppend (other) {\n    var inner = this.right.leafAppend(other);\n    if (inner) { return new Append(this.left, inner) }\n  };\n\n  Append.prototype.leafPrepend = function leafPrepend (other) {\n    var inner = this.left.leafPrepend(other);\n    if (inner) { return new Append(inner, this.right) }\n  };\n\n  Append.prototype.appendInner = function appendInner (other) {\n    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1)\n      { return new Append(this.left, new Append(this.right, other)) }\n    return new Append(this, other)\n  };\n\n  return Append;\n}(RopeSequence));\n\nexport default RopeSequence;\n", "import RopeSequence from 'rope-sequence';\nimport { Mapping } from 'prosemirror-transform';\nimport { PluginKey, Plugin } from 'prosemirror-state';\n\n// ProseMirror's history isn't simply a way to roll back to a previous\n// state, because ProseMirror supports applying changes without adding\n// them to the history (for example during collaboration).\n//\n// To this end, each 'Branch' (one for the undo history and one for\n// the redo history) keeps an array of 'Items', which can optionally\n// hold a step (an actual undoable change), and always hold a position\n// map (which is needed to move changes below them to apply to the\n// current document).\n//\n// An item that has both a step and a selection bookmark is the start\n// of an 'event' — a group of changes that will be undone or redone at\n// once. (It stores only the bookmark, since that way we don't have to\n// provide a document until the selection is actually applied, which\n// is useful when compressing.)\n// Used to schedule history compression\nconst max_empty_items = 500;\nclass Branch {\n    constructor(items, eventCount) {\n        this.items = items;\n        this.eventCount = eventCount;\n    }\n    // Pop the latest event off the branch's history and apply it\n    // to a document transform.\n    popEvent(state, preserveItems) {\n        if (this.eventCount == 0)\n            return null;\n        let end = this.items.length;\n        for (;; end--) {\n            let next = this.items.get(end - 1);\n            if (next.selection) {\n                --end;\n                break;\n            }\n        }\n        let remap, mapFrom;\n        if (preserveItems) {\n            remap = this.remapping(end, this.items.length);\n            mapFrom = remap.maps.length;\n        }\n        let transform = state.tr;\n        let selection, remaining;\n        let addAfter = [], addBefore = [];\n        this.items.forEach((item, i) => {\n            if (!item.step) {\n                if (!remap) {\n                    remap = this.remapping(end, i + 1);\n                    mapFrom = remap.maps.length;\n                }\n                mapFrom--;\n                addBefore.push(item);\n                return;\n            }\n            if (remap) {\n                addBefore.push(new Item(item.map));\n                let step = item.step.map(remap.slice(mapFrom)), map;\n                if (step && transform.maybeStep(step).doc) {\n                    map = transform.mapping.maps[transform.mapping.maps.length - 1];\n                    addAfter.push(new Item(map, undefined, undefined, addAfter.length + addBefore.length));\n                }\n                mapFrom--;\n                if (map)\n                    remap.appendMap(map, mapFrom);\n            }\n            else {\n                transform.maybeStep(item.step);\n            }\n            if (item.selection) {\n                selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;\n                remaining = new Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);\n                return false;\n            }\n        }, this.items.length, 0);\n        return { remaining: remaining, transform, selection: selection };\n    }\n    // Create a new branch with the given transform added.\n    addTransform(transform, selection, histOptions, preserveItems) {\n        let newItems = [], eventCount = this.eventCount;\n        let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;\n        for (let i = 0; i < transform.steps.length; i++) {\n            let step = transform.steps[i].invert(transform.docs[i]);\n            let item = new Item(transform.mapping.maps[i], step, selection), merged;\n            if (merged = lastItem && lastItem.merge(item)) {\n                item = merged;\n                if (i)\n                    newItems.pop();\n                else\n                    oldItems = oldItems.slice(0, oldItems.length - 1);\n            }\n            newItems.push(item);\n            if (selection) {\n                eventCount++;\n                selection = undefined;\n            }\n            if (!preserveItems)\n                lastItem = item;\n        }\n        let overflow = eventCount - histOptions.depth;\n        if (overflow > DEPTH_OVERFLOW) {\n            oldItems = cutOffEvents(oldItems, overflow);\n            eventCount -= overflow;\n        }\n        return new Branch(oldItems.append(newItems), eventCount);\n    }\n    remapping(from, to) {\n        let maps = new Mapping;\n        this.items.forEach((item, i) => {\n            let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from\n                ? maps.maps.length - item.mirrorOffset : undefined;\n            maps.appendMap(item.map, mirrorPos);\n        }, from, to);\n        return maps;\n    }\n    addMaps(array) {\n        if (this.eventCount == 0)\n            return this;\n        return new Branch(this.items.append(array.map(map => new Item(map))), this.eventCount);\n    }\n    // When the collab module receives remote changes, the history has\n    // to know about those, so that it can adjust the steps that were\n    // rebased on top of the remote changes, and include the position\n    // maps for the remote changes in its array of items.\n    rebased(rebasedTransform, rebasedCount) {\n        if (!this.eventCount)\n            return this;\n        let rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount);\n        let mapping = rebasedTransform.mapping;\n        let newUntil = rebasedTransform.steps.length;\n        let eventCount = this.eventCount;\n        this.items.forEach(item => { if (item.selection)\n            eventCount--; }, start);\n        let iRebased = rebasedCount;\n        this.items.forEach(item => {\n            let pos = mapping.getMirror(--iRebased);\n            if (pos == null)\n                return;\n            newUntil = Math.min(newUntil, pos);\n            let map = mapping.maps[pos];\n            if (item.step) {\n                let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);\n                let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));\n                if (selection)\n                    eventCount++;\n                rebasedItems.push(new Item(map, step, selection));\n            }\n            else {\n                rebasedItems.push(new Item(map));\n            }\n        }, start);\n        let newMaps = [];\n        for (let i = rebasedCount; i < newUntil; i++)\n            newMaps.push(new Item(mapping.maps[i]));\n        let items = this.items.slice(0, start).append(newMaps).append(rebasedItems);\n        let branch = new Branch(items, eventCount);\n        if (branch.emptyItemCount() > max_empty_items)\n            branch = branch.compress(this.items.length - rebasedItems.length);\n        return branch;\n    }\n    emptyItemCount() {\n        let count = 0;\n        this.items.forEach(item => { if (!item.step)\n            count++; });\n        return count;\n    }\n    // Compressing a branch means rewriting it to push the air (map-only\n    // items) out. During collaboration, these naturally accumulate\n    // because each remote change adds one. The `upto` argument is used\n    // to ensure that only the items below a given level are compressed,\n    // because `rebased` relies on a clean, untouched set of items in\n    // order to associate old items with rebased steps.\n    compress(upto = this.items.length) {\n        let remap = this.remapping(0, upto), mapFrom = remap.maps.length;\n        let items = [], events = 0;\n        this.items.forEach((item, i) => {\n            if (i >= upto) {\n                items.push(item);\n                if (item.selection)\n                    events++;\n            }\n            else if (item.step) {\n                let step = item.step.map(remap.slice(mapFrom)), map = step && step.getMap();\n                mapFrom--;\n                if (map)\n                    remap.appendMap(map, mapFrom);\n                if (step) {\n                    let selection = item.selection && item.selection.map(remap.slice(mapFrom));\n                    if (selection)\n                        events++;\n                    let newItem = new Item(map.invert(), step, selection), merged, last = items.length - 1;\n                    if (merged = items.length && items[last].merge(newItem))\n                        items[last] = merged;\n                    else\n                        items.push(newItem);\n                }\n            }\n            else if (item.map) {\n                mapFrom--;\n            }\n        }, this.items.length, 0);\n        return new Branch(RopeSequence.from(items.reverse()), events);\n    }\n}\nBranch.empty = new Branch(RopeSequence.empty, 0);\nfunction cutOffEvents(items, n) {\n    let cutPoint;\n    items.forEach((item, i) => {\n        if (item.selection && (n-- == 0)) {\n            cutPoint = i;\n            return false;\n        }\n    });\n    return items.slice(cutPoint);\n}\nclass Item {\n    constructor(\n    // The (forward) step map for this item.\n    map, \n    // The inverted step\n    step, \n    // If this is non-null, this item is the start of a group, and\n    // this selection is the starting selection for the group (the one\n    // that was active before the first step was applied)\n    selection, \n    // If this item is the inverse of a previous mapping on the stack,\n    // this points at the inverse's offset\n    mirrorOffset) {\n        this.map = map;\n        this.step = step;\n        this.selection = selection;\n        this.mirrorOffset = mirrorOffset;\n    }\n    merge(other) {\n        if (this.step && other.step && !other.selection) {\n            let step = other.step.merge(this.step);\n            if (step)\n                return new Item(step.getMap().invert(), step, this.selection);\n        }\n    }\n}\n// The value of the state field that tracks undo/redo history for that\n// state. Will be stored in the plugin state when the history plugin\n// is active.\nclass HistoryState {\n    constructor(done, undone, prevRanges, prevTime, prevComposition) {\n        this.done = done;\n        this.undone = undone;\n        this.prevRanges = prevRanges;\n        this.prevTime = prevTime;\n        this.prevComposition = prevComposition;\n    }\n}\nconst DEPTH_OVERFLOW = 20;\n// Record a transformation in undo history.\nfunction applyTransaction(history, state, tr, options) {\n    let historyTr = tr.getMeta(historyKey), rebased;\n    if (historyTr)\n        return historyTr.historyState;\n    if (tr.getMeta(closeHistoryKey))\n        history = new HistoryState(history.done, history.undone, null, 0, -1);\n    let appended = tr.getMeta(\"appendedTransaction\");\n    if (tr.steps.length == 0) {\n        return history;\n    }\n    else if (appended && appended.getMeta(historyKey)) {\n        if (appended.getMeta(historyKey).redo)\n            return new HistoryState(history.done.addTransform(tr, undefined, options, mustPreserveItems(state)), history.undone, rangesFor(tr.mapping.maps), history.prevTime, history.prevComposition);\n        else\n            return new HistoryState(history.done, history.undone.addTransform(tr, undefined, options, mustPreserveItems(state)), null, history.prevTime, history.prevComposition);\n    }\n    else if (tr.getMeta(\"addToHistory\") !== false && !(appended && appended.getMeta(\"addToHistory\") === false)) {\n        // Group transforms that occur in quick succession into one event.\n        let composition = tr.getMeta(\"composition\");\n        let newGroup = history.prevTime == 0 ||\n            (!appended && history.prevComposition != composition &&\n                (history.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history.prevRanges)));\n        let prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps);\n        return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : undefined, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time, composition == null ? history.prevComposition : composition);\n    }\n    else if (rebased = tr.getMeta(\"rebased\")) {\n        // Used by the collab module to tell the history that some of its\n        // content has been rebased.\n        return new HistoryState(history.done.rebased(tr, rebased), history.undone.rebased(tr, rebased), mapRanges(history.prevRanges, tr.mapping), history.prevTime, history.prevComposition);\n    }\n    else {\n        return new HistoryState(history.done.addMaps(tr.mapping.maps), history.undone.addMaps(tr.mapping.maps), mapRanges(history.prevRanges, tr.mapping), history.prevTime, history.prevComposition);\n    }\n}\nfunction isAdjacentTo(transform, prevRanges) {\n    if (!prevRanges)\n        return false;\n    if (!transform.docChanged)\n        return true;\n    let adjacent = false;\n    transform.mapping.maps[0].forEach((start, end) => {\n        for (let i = 0; i < prevRanges.length; i += 2)\n            if (start <= prevRanges[i + 1] && end >= prevRanges[i])\n                adjacent = true;\n    });\n    return adjacent;\n}\nfunction rangesFor(maps) {\n    let result = [];\n    for (let i = maps.length - 1; i >= 0 && result.length == 0; i--)\n        maps[i].forEach((_from, _to, from, to) => result.push(from, to));\n    return result;\n}\nfunction mapRanges(ranges, mapping) {\n    if (!ranges)\n        return null;\n    let result = [];\n    for (let i = 0; i < ranges.length; i += 2) {\n        let from = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);\n        if (from <= to)\n            result.push(from, to);\n    }\n    return result;\n}\n// Apply the latest event from one branch to the document and shift the event\n// onto the other branch.\nfunction histTransaction(history, state, redo) {\n    let preserveItems = mustPreserveItems(state);\n    let histOptions = historyKey.get(state).spec.config;\n    let pop = (redo ? history.undone : history.done).popEvent(state, preserveItems);\n    if (!pop)\n        return null;\n    let selection = pop.selection.resolve(pop.transform.doc);\n    let added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);\n    let newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0, -1);\n    return pop.transform.setSelection(selection).setMeta(historyKey, { redo, historyState: newHist });\n}\nlet cachedPreserveItems = false, cachedPreserveItemsPlugins = null;\n// Check whether any plugin in the given state has a\n// `historyPreserveItems` property in its spec, in which case we must\n// preserve steps exactly as they came in, so that they can be\n// rebased.\nfunction mustPreserveItems(state) {\n    let plugins = state.plugins;\n    if (cachedPreserveItemsPlugins != plugins) {\n        cachedPreserveItems = false;\n        cachedPreserveItemsPlugins = plugins;\n        for (let i = 0; i < plugins.length; i++)\n            if (plugins[i].spec.historyPreserveItems) {\n                cachedPreserveItems = true;\n                break;\n            }\n    }\n    return cachedPreserveItems;\n}\n/**\nSet a flag on the given transaction that will prevent further steps\nfrom being appended to an existing history event (so that they\nrequire a separate undo command to undo).\n*/\nfunction closeHistory(tr) {\n    return tr.setMeta(closeHistoryKey, true);\n}\nconst historyKey = new PluginKey(\"history\");\nconst closeHistoryKey = new PluginKey(\"closeHistory\");\n/**\nReturns a plugin that enables the undo history for an editor. The\nplugin will track undo and redo stacks, which can be used with the\n[`undo`](https://prosemirror.net/docs/ref/#history.undo) and [`redo`](https://prosemirror.net/docs/ref/#history.redo) commands.\n\nYou can set an `\"addToHistory\"` [metadata\nproperty](https://prosemirror.net/docs/ref/#state.Transaction.setMeta) of `false` on a transaction\nto prevent it from being rolled back by undo.\n*/\nfunction history(config = {}) {\n    config = { depth: config.depth || 100,\n        newGroupDelay: config.newGroupDelay || 500 };\n    return new Plugin({\n        key: historyKey,\n        state: {\n            init() {\n                return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);\n            },\n            apply(tr, hist, state) {\n                return applyTransaction(hist, state, tr, config);\n            }\n        },\n        config,\n        props: {\n            handleDOMEvents: {\n                beforeinput(view, e) {\n                    let inputType = e.inputType;\n                    let command = inputType == \"historyUndo\" ? undo : inputType == \"historyRedo\" ? redo : null;\n                    if (!command)\n                        return false;\n                    e.preventDefault();\n                    return command(view.state, view.dispatch);\n                }\n            }\n        }\n    });\n}\nfunction buildCommand(redo, scroll) {\n    return (state, dispatch) => {\n        let hist = historyKey.getState(state);\n        if (!hist || (redo ? hist.undone : hist.done).eventCount == 0)\n            return false;\n        if (dispatch) {\n            let tr = histTransaction(hist, state, redo);\n            if (tr)\n                dispatch(scroll ? tr.scrollIntoView() : tr);\n        }\n        return true;\n    };\n}\n/**\nA command function that undoes the last change, if any.\n*/\nconst undo = buildCommand(false, true);\n/**\nA command function that redoes the last undone change, if any.\n*/\nconst redo = buildCommand(true, true);\n/**\nA command function that undoes the last change. Don't scroll the\nselection into view.\n*/\nconst undoNoScroll = buildCommand(false, false);\n/**\nA command function that redoes the last undone change. Don't\nscroll the selection into view.\n*/\nconst redoNoScroll = buildCommand(true, false);\n/**\nThe amount of undoable events available in a given state.\n*/\nfunction undoDepth(state) {\n    let hist = historyKey.getState(state);\n    return hist ? hist.done.eventCount : 0;\n}\n/**\nThe amount of redoable events available in a given editor state.\n*/\nfunction redoDepth(state) {\n    let hist = historyKey.getState(state);\n    return hist ? hist.undone.eventCount : 0;\n}\n\nexport { closeHistory, history, redo, redoDepth, redoNoScroll, undo, undoDepth, undoNoScroll };\n", "import { liftTarget, replaceStep, ReplaceStep, canJoin, joinPoint, canSplit, ReplaceAroundStep, findWrapping } from 'prosemirror-transform';\nimport { Slice, Fragment } from 'prosemirror-model';\nimport { NodeSelection, Selection, TextSelection, AllSelection, SelectionRange } from 'prosemirror-state';\n\n/**\nDelete the selection, if there is one.\n*/\nconst deleteSelection = (state, dispatch) => {\n    if (state.selection.empty)\n        return false;\n    if (dispatch)\n        dispatch(state.tr.deleteSelection().scrollIntoView());\n    return true;\n};\nfunction atBlockStart(state, view) {\n    let { $cursor } = state.selection;\n    if (!$cursor || (view ? !view.endOfTextblock(\"backward\", state)\n        : $cursor.parentOffset > 0))\n        return null;\n    return $cursor;\n}\n/**\nIf the selection is empty and at the start of a textblock, try to\nreduce the distance between that block and the one before it—if\nthere's a block directly before it that can be joined, join them.\nIf not, try to move the selected block closer to the next one in\nthe document structure by lifting it out of its parent or moving it\ninto a parent of the previous block. Will use the view for accurate\n(bidi-aware) start-of-textblock detection if given.\n*/\nconst joinBackward = (state, dispatch, view) => {\n    let $cursor = atBlockStart(state, view);\n    if (!$cursor)\n        return false;\n    let $cut = findCutBefore($cursor);\n    // If there is no node before this, try to lift\n    if (!$cut) {\n        let range = $cursor.blockRange(), target = range && liftTarget(range);\n        if (target == null)\n            return false;\n        if (dispatch)\n            dispatch(state.tr.lift(range, target).scrollIntoView());\n        return true;\n    }\n    let before = $cut.nodeBefore;\n    // Apply the joining algorithm\n    if (deleteBarrier(state, $cut, dispatch, -1))\n        return true;\n    // If the node below has no content and the node above is\n    // selectable, delete the node below and select the one above.\n    if ($cursor.parent.content.size == 0 &&\n        (textblockAt(before, \"end\") || NodeSelection.isSelectable(before))) {\n        for (let depth = $cursor.depth;; depth--) {\n            let delStep = replaceStep(state.doc, $cursor.before(depth), $cursor.after(depth), Slice.empty);\n            if (delStep && delStep.slice.size < delStep.to - delStep.from) {\n                if (dispatch) {\n                    let tr = state.tr.step(delStep);\n                    tr.setSelection(textblockAt(before, \"end\")\n                        ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1)\n                        : NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));\n                    dispatch(tr.scrollIntoView());\n                }\n                return true;\n            }\n            if (depth == 1 || $cursor.node(depth - 1).childCount > 1)\n                break;\n        }\n    }\n    // If the node before is an atom, delete it\n    if (before.isAtom && $cut.depth == $cursor.depth - 1) {\n        if (dispatch)\n            dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());\n        return true;\n    }\n    return false;\n};\n/**\nA more limited form of [`joinBackward`]($commands.joinBackward)\nthat only tries to join the current textblock to the one before\nit, if the cursor is at the start of a textblock.\n*/\nconst joinTextblockBackward = (state, dispatch, view) => {\n    let $cursor = atBlockStart(state, view);\n    if (!$cursor)\n        return false;\n    let $cut = findCutBefore($cursor);\n    return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;\n};\n/**\nA more limited form of [`joinForward`]($commands.joinForward)\nthat only tries to join the current textblock to the one after\nit, if the cursor is at the end of a textblock.\n*/\nconst joinTextblockForward = (state, dispatch, view) => {\n    let $cursor = atBlockEnd(state, view);\n    if (!$cursor)\n        return false;\n    let $cut = findCutAfter($cursor);\n    return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;\n};\nfunction joinTextblocksAround(state, $cut, dispatch) {\n    let before = $cut.nodeBefore, beforeText = before, beforePos = $cut.pos - 1;\n    for (; !beforeText.isTextblock; beforePos--) {\n        if (beforeText.type.spec.isolating)\n            return false;\n        let child = beforeText.lastChild;\n        if (!child)\n            return false;\n        beforeText = child;\n    }\n    let after = $cut.nodeAfter, afterText = after, afterPos = $cut.pos + 1;\n    for (; !afterText.isTextblock; afterPos++) {\n        if (afterText.type.spec.isolating)\n            return false;\n        let child = afterText.firstChild;\n        if (!child)\n            return false;\n        afterText = child;\n    }\n    let step = replaceStep(state.doc, beforePos, afterPos, Slice.empty);\n    if (!step || step.from != beforePos ||\n        step instanceof ReplaceStep && step.slice.size >= afterPos - beforePos)\n        return false;\n    if (dispatch) {\n        let tr = state.tr.step(step);\n        tr.setSelection(TextSelection.create(tr.doc, beforePos));\n        dispatch(tr.scrollIntoView());\n    }\n    return true;\n}\nfunction textblockAt(node, side, only = false) {\n    for (let scan = node; scan; scan = (side == \"start\" ? scan.firstChild : scan.lastChild)) {\n        if (scan.isTextblock)\n            return true;\n        if (only && scan.childCount != 1)\n            return false;\n    }\n    return false;\n}\n/**\nWhen the selection is empty and at the start of a textblock, select\nthe node before that textblock, if possible. This is intended to be\nbound to keys like backspace, after\n[`joinBackward`](https://prosemirror.net/docs/ref/#commands.joinBackward) or other deleting\ncommands, as a fall-back behavior when the schema doesn't allow\ndeletion at the selected point.\n*/\nconst selectNodeBackward = (state, dispatch, view) => {\n    let { $head, empty } = state.selection, $cut = $head;\n    if (!empty)\n        return false;\n    if ($head.parent.isTextblock) {\n        if (view ? !view.endOfTextblock(\"backward\", state) : $head.parentOffset > 0)\n            return false;\n        $cut = findCutBefore($head);\n    }\n    let node = $cut && $cut.nodeBefore;\n    if (!node || !NodeSelection.isSelectable(node))\n        return false;\n    if (dispatch)\n        dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());\n    return true;\n};\nfunction findCutBefore($pos) {\n    if (!$pos.parent.type.spec.isolating)\n        for (let i = $pos.depth - 1; i >= 0; i--) {\n            if ($pos.index(i) > 0)\n                return $pos.doc.resolve($pos.before(i + 1));\n            if ($pos.node(i).type.spec.isolating)\n                break;\n        }\n    return null;\n}\nfunction atBlockEnd(state, view) {\n    let { $cursor } = state.selection;\n    if (!$cursor || (view ? !view.endOfTextblock(\"forward\", state)\n        : $cursor.parentOffset < $cursor.parent.content.size))\n        return null;\n    return $cursor;\n}\n/**\nIf the selection is empty and the cursor is at the end of a\ntextblock, try to reduce or remove the boundary between that block\nand the one after it, either by joining them or by moving the other\nblock closer to this one in the tree structure. Will use the view\nfor accurate start-of-textblock detection if given.\n*/\nconst joinForward = (state, dispatch, view) => {\n    let $cursor = atBlockEnd(state, view);\n    if (!$cursor)\n        return false;\n    let $cut = findCutAfter($cursor);\n    // If there is no node after this, there's nothing to do\n    if (!$cut)\n        return false;\n    let after = $cut.nodeAfter;\n    // Try the joining algorithm\n    if (deleteBarrier(state, $cut, dispatch, 1))\n        return true;\n    // If the node above has no content and the node below is\n    // selectable, delete the node above and select the one below.\n    if ($cursor.parent.content.size == 0 &&\n        (textblockAt(after, \"start\") || NodeSelection.isSelectable(after))) {\n        let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);\n        if (delStep && delStep.slice.size < delStep.to - delStep.from) {\n            if (dispatch) {\n                let tr = state.tr.step(delStep);\n                tr.setSelection(textblockAt(after, \"start\") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1)\n                    : NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));\n                dispatch(tr.scrollIntoView());\n            }\n            return true;\n        }\n    }\n    // If the next node is an atom, delete it\n    if (after.isAtom && $cut.depth == $cursor.depth - 1) {\n        if (dispatch)\n            dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());\n        return true;\n    }\n    return false;\n};\n/**\nWhen the selection is empty and at the end of a textblock, select\nthe node coming after that textblock, if possible. This is intended\nto be bound to keys like delete, after\n[`joinForward`](https://prosemirror.net/docs/ref/#commands.joinForward) and similar deleting\ncommands, to provide a fall-back behavior when the schema doesn't\nallow deletion at the selected point.\n*/\nconst selectNodeForward = (state, dispatch, view) => {\n    let { $head, empty } = state.selection, $cut = $head;\n    if (!empty)\n        return false;\n    if ($head.parent.isTextblock) {\n        if (view ? !view.endOfTextblock(\"forward\", state) : $head.parentOffset < $head.parent.content.size)\n            return false;\n        $cut = findCutAfter($head);\n    }\n    let node = $cut && $cut.nodeAfter;\n    if (!node || !NodeSelection.isSelectable(node))\n        return false;\n    if (dispatch)\n        dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());\n    return true;\n};\nfunction findCutAfter($pos) {\n    if (!$pos.parent.type.spec.isolating)\n        for (let i = $pos.depth - 1; i >= 0; i--) {\n            let parent = $pos.node(i);\n            if ($pos.index(i) + 1 < parent.childCount)\n                return $pos.doc.resolve($pos.after(i + 1));\n            if (parent.type.spec.isolating)\n                break;\n        }\n    return null;\n}\n/**\nJoin the selected block or, if there is a text selection, the\nclosest ancestor block of the selection that can be joined, with\nthe sibling above it.\n*/\nconst joinUp = (state, dispatch) => {\n    let sel = state.selection, nodeSel = sel instanceof NodeSelection, point;\n    if (nodeSel) {\n        if (sel.node.isTextblock || !canJoin(state.doc, sel.from))\n            return false;\n        point = sel.from;\n    }\n    else {\n        point = joinPoint(state.doc, sel.from, -1);\n        if (point == null)\n            return false;\n    }\n    if (dispatch) {\n        let tr = state.tr.join(point);\n        if (nodeSel)\n            tr.setSelection(NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));\n        dispatch(tr.scrollIntoView());\n    }\n    return true;\n};\n/**\nJoin the selected block, or the closest ancestor of the selection\nthat can be joined, with the sibling after it.\n*/\nconst joinDown = (state, dispatch) => {\n    let sel = state.selection, point;\n    if (sel instanceof NodeSelection) {\n        if (sel.node.isTextblock || !canJoin(state.doc, sel.to))\n            return false;\n        point = sel.to;\n    }\n    else {\n        point = joinPoint(state.doc, sel.to, 1);\n        if (point == null)\n            return false;\n    }\n    if (dispatch)\n        dispatch(state.tr.join(point).scrollIntoView());\n    return true;\n};\n/**\nLift the selected block, or the closest ancestor block of the\nselection that can be lifted, out of its parent node.\n*/\nconst lift = (state, dispatch) => {\n    let { $from, $to } = state.selection;\n    let range = $from.blockRange($to), target = range && liftTarget(range);\n    if (target == null)\n        return false;\n    if (dispatch)\n        dispatch(state.tr.lift(range, target).scrollIntoView());\n    return true;\n};\n/**\nIf the selection is in a node whose type has a truthy\n[`code`](https://prosemirror.net/docs/ref/#model.NodeSpec.code) property in its spec, replace the\nselection with a newline character.\n*/\nconst newlineInCode = (state, dispatch) => {\n    let { $head, $anchor } = state.selection;\n    if (!$head.parent.type.spec.code || !$head.sameParent($anchor))\n        return false;\n    if (dispatch)\n        dispatch(state.tr.insertText(\"\\n\").scrollIntoView());\n    return true;\n};\nfunction defaultBlockAt(match) {\n    for (let i = 0; i < match.edgeCount; i++) {\n        let { type } = match.edge(i);\n        if (type.isTextblock && !type.hasRequiredAttrs())\n            return type;\n    }\n    return null;\n}\n/**\nWhen the selection is in a node with a truthy\n[`code`](https://prosemirror.net/docs/ref/#model.NodeSpec.code) property in its spec, create a\ndefault block after the code block, and move the cursor there.\n*/\nconst exitCode = (state, dispatch) => {\n    let { $head, $anchor } = state.selection;\n    if (!$head.parent.type.spec.code || !$head.sameParent($anchor))\n        return false;\n    let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after));\n    if (!type || !above.canReplaceWith(after, after, type))\n        return false;\n    if (dispatch) {\n        let pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill());\n        tr.setSelection(Selection.near(tr.doc.resolve(pos), 1));\n        dispatch(tr.scrollIntoView());\n    }\n    return true;\n};\n/**\nIf a block node is selected, create an empty paragraph before (if\nit is its parent's first child) or after it.\n*/\nconst createParagraphNear = (state, dispatch) => {\n    let sel = state.selection, { $from, $to } = sel;\n    if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent)\n        return false;\n    let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));\n    if (!type || !type.isTextblock)\n        return false;\n    if (dispatch) {\n        let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;\n        let tr = state.tr.insert(side, type.createAndFill());\n        tr.setSelection(TextSelection.create(tr.doc, side + 1));\n        dispatch(tr.scrollIntoView());\n    }\n    return true;\n};\n/**\nIf the cursor is in an empty textblock that can be lifted, lift the\nblock.\n*/\nconst liftEmptyBlock = (state, dispatch) => {\n    let { $cursor } = state.selection;\n    if (!$cursor || $cursor.parent.content.size)\n        return false;\n    if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {\n        let before = $cursor.before();\n        if (canSplit(state.doc, before)) {\n            if (dispatch)\n                dispatch(state.tr.split(before).scrollIntoView());\n            return true;\n        }\n    }\n    let range = $cursor.blockRange(), target = range && liftTarget(range);\n    if (target == null)\n        return false;\n    if (dispatch)\n        dispatch(state.tr.lift(range, target).scrollIntoView());\n    return true;\n};\n/**\nCreate a variant of [`splitBlock`](https://prosemirror.net/docs/ref/#commands.splitBlock) that uses\na custom function to determine the type of the newly split off block.\n*/\nfunction splitBlockAs(splitNode) {\n    return (state, dispatch) => {\n        let { $from, $to } = state.selection;\n        if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {\n            if (!$from.parentOffset || !canSplit(state.doc, $from.pos))\n                return false;\n            if (dispatch)\n                dispatch(state.tr.split($from.pos).scrollIntoView());\n            return true;\n        }\n        if (!$from.depth)\n            return false;\n        let types = [];\n        let splitDepth, deflt, atEnd = false, atStart = false;\n        for (let d = $from.depth;; d--) {\n            let node = $from.node(d);\n            if (node.isBlock) {\n                atEnd = $from.end(d) == $from.pos + ($from.depth - d);\n                atStart = $from.start(d) == $from.pos - ($from.depth - d);\n                deflt = defaultBlockAt($from.node(d - 1).contentMatchAt($from.indexAfter(d - 1)));\n                let splitType = splitNode && splitNode($to.parent, atEnd, $from);\n                types.unshift(splitType || (atEnd && deflt ? { type: deflt } : null));\n                splitDepth = d;\n                break;\n            }\n            else {\n                if (d == 1)\n                    return false;\n                types.unshift(null);\n            }\n        }\n        let tr = state.tr;\n        if (state.selection instanceof TextSelection || state.selection instanceof AllSelection)\n            tr.deleteSelection();\n        let splitPos = tr.mapping.map($from.pos);\n        let can = canSplit(tr.doc, splitPos, types.length, types);\n        if (!can) {\n            types[0] = deflt ? { type: deflt } : null;\n            can = canSplit(tr.doc, splitPos, types.length, types);\n        }\n        tr.split(splitPos, types.length, types);\n        if (!atEnd && atStart && $from.node(splitDepth).type != deflt) {\n            let first = tr.mapping.map($from.before(splitDepth)), $first = tr.doc.resolve(first);\n            if (deflt && $from.node(splitDepth - 1).canReplaceWith($first.index(), $first.index() + 1, deflt))\n                tr.setNodeMarkup(tr.mapping.map($from.before(splitDepth)), deflt);\n        }\n        if (dispatch)\n            dispatch(tr.scrollIntoView());\n        return true;\n    };\n}\n/**\nSplit the parent block of the selection. If the selection is a text\nselection, also delete its content.\n*/\nconst splitBlock = splitBlockAs();\n/**\nActs like [`splitBlock`](https://prosemirror.net/docs/ref/#commands.splitBlock), but without\nresetting the set of active marks at the cursor.\n*/\nconst splitBlockKeepMarks = (state, dispatch) => {\n    return splitBlock(state, dispatch && (tr => {\n        let marks = state.storedMarks || (state.selection.$to.parentOffset && state.selection.$from.marks());\n        if (marks)\n            tr.ensureMarks(marks);\n        dispatch(tr);\n    }));\n};\n/**\nMove the selection to the node wrapping the current selection, if\nany. (Will not select the document node.)\n*/\nconst selectParentNode = (state, dispatch) => {\n    let { $from, to } = state.selection, pos;\n    let same = $from.sharedDepth(to);\n    if (same == 0)\n        return false;\n    pos = $from.before(same);\n    if (dispatch)\n        dispatch(state.tr.setSelection(NodeSelection.create(state.doc, pos)));\n    return true;\n};\n/**\nSelect the whole document.\n*/\nconst selectAll = (state, dispatch) => {\n    if (dispatch)\n        dispatch(state.tr.setSelection(new AllSelection(state.doc)));\n    return true;\n};\nfunction joinMaybeClear(state, $pos, dispatch) {\n    let before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index();\n    if (!before || !after || !before.type.compatibleContent(after.type))\n        return false;\n    if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {\n        if (dispatch)\n            dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());\n        return true;\n    }\n    if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos)))\n        return false;\n    if (dispatch)\n        dispatch(state.tr.join($pos.pos).scrollIntoView());\n    return true;\n}\nfunction deleteBarrier(state, $cut, dispatch, dir) {\n    let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;\n    let isolated = before.type.spec.isolating || after.type.spec.isolating;\n    if (!isolated && joinMaybeClear(state, $cut, dispatch))\n        return true;\n    let canDelAfter = !isolated && $cut.parent.canReplace($cut.index(), $cut.index() + 1);\n    if (canDelAfter &&\n        (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) &&\n        match.matchType(conn[0] || after.type).validEnd) {\n        if (dispatch) {\n            let end = $cut.pos + after.nodeSize, wrap = Fragment.empty;\n            for (let i = conn.length - 1; i >= 0; i--)\n                wrap = Fragment.from(conn[i].create(null, wrap));\n            wrap = Fragment.from(before.copy(wrap));\n            let tr = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new Slice(wrap, 1, 0), conn.length, true));\n            let $joinAt = tr.doc.resolve(end + 2 * conn.length);\n            if ($joinAt.nodeAfter && $joinAt.nodeAfter.type == before.type &&\n                canJoin(tr.doc, $joinAt.pos))\n                tr.join($joinAt.pos);\n            dispatch(tr.scrollIntoView());\n        }\n        return true;\n    }\n    let selAfter = after.type.spec.isolating || (dir > 0 && isolated) ? null : Selection.findFrom($cut, 1);\n    let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range);\n    if (target != null && target >= $cut.depth) {\n        if (dispatch)\n            dispatch(state.tr.lift(range, target).scrollIntoView());\n        return true;\n    }\n    if (canDelAfter && textblockAt(after, \"start\", true) && textblockAt(before, \"end\")) {\n        let at = before, wrap = [];\n        for (;;) {\n            wrap.push(at);\n            if (at.isTextblock)\n                break;\n            at = at.lastChild;\n        }\n        let afterText = after, afterDepth = 1;\n        for (; !afterText.isTextblock; afterText = afterText.firstChild)\n            afterDepth++;\n        if (at.canReplace(at.childCount, at.childCount, afterText.content)) {\n            if (dispatch) {\n                let end = Fragment.empty;\n                for (let i = wrap.length - 1; i >= 0; i--)\n                    end = Fragment.from(wrap[i].copy(end));\n                let tr = state.tr.step(new ReplaceAroundStep($cut.pos - wrap.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new Slice(end, wrap.length, 0), 0, true));\n                dispatch(tr.scrollIntoView());\n            }\n            return true;\n        }\n    }\n    return false;\n}\nfunction selectTextblockSide(side) {\n    return function (state, dispatch) {\n        let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;\n        let depth = $pos.depth;\n        while ($pos.node(depth).isInline) {\n            if (!depth)\n                return false;\n            depth--;\n        }\n        if (!$pos.node(depth).isTextblock)\n            return false;\n        if (dispatch)\n            dispatch(state.tr.setSelection(TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));\n        return true;\n    };\n}\n/**\nMoves the cursor to the start of current text block.\n*/\nconst selectTextblockStart = selectTextblockSide(-1);\n/**\nMoves the cursor to the end of current text block.\n*/\nconst selectTextblockEnd = selectTextblockSide(1);\n// Parameterized commands\n/**\nWrap the selection in a node of the given type with the given\nattributes.\n*/\nfunction wrapIn(nodeType, attrs = null) {\n    return function (state, dispatch) {\n        let { $from, $to } = state.selection;\n        let range = $from.blockRange($to), wrapping = range && findWrapping(range, nodeType, attrs);\n        if (!wrapping)\n            return false;\n        if (dispatch)\n            dispatch(state.tr.wrap(range, wrapping).scrollIntoView());\n        return true;\n    };\n}\n/**\nReturns a command that tries to set the selected textblocks to the\ngiven node type with the given attributes.\n*/\nfunction setBlockType(nodeType, attrs = null) {\n    return function (state, dispatch) {\n        let applicable = false;\n        for (let i = 0; i < state.selection.ranges.length && !applicable; i++) {\n            let { $from: { pos: from }, $to: { pos: to } } = state.selection.ranges[i];\n            state.doc.nodesBetween(from, to, (node, pos) => {\n                if (applicable)\n                    return false;\n                if (!node.isTextblock || node.hasMarkup(nodeType, attrs))\n                    return;\n                if (node.type == nodeType) {\n                    applicable = true;\n                }\n                else {\n                    let $pos = state.doc.resolve(pos), index = $pos.index();\n                    applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);\n                }\n            });\n        }\n        if (!applicable)\n            return false;\n        if (dispatch) {\n            let tr = state.tr;\n            for (let i = 0; i < state.selection.ranges.length; i++) {\n                let { $from: { pos: from }, $to: { pos: to } } = state.selection.ranges[i];\n                tr.setBlockType(from, to, nodeType, attrs);\n            }\n            dispatch(tr.scrollIntoView());\n        }\n        return true;\n    };\n}\nfunction markApplies(doc, ranges, type, enterAtoms) {\n    for (let i = 0; i < ranges.length; i++) {\n        let { $from, $to } = ranges[i];\n        let can = $from.depth == 0 ? doc.inlineContent && doc.type.allowsMarkType(type) : false;\n        doc.nodesBetween($from.pos, $to.pos, (node, pos) => {\n            if (can || !enterAtoms && node.isAtom && node.isInline && pos >= $from.pos && pos + node.nodeSize <= $to.pos)\n                return false;\n            can = node.inlineContent && node.type.allowsMarkType(type);\n        });\n        if (can)\n            return true;\n    }\n    return false;\n}\nfunction removeInlineAtoms(ranges) {\n    let result = [];\n    for (let i = 0; i < ranges.length; i++) {\n        let { $from, $to } = ranges[i];\n        $from.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {\n            if (node.isAtom && node.content.size && node.isInline && pos >= $from.pos && pos + node.nodeSize <= $to.pos) {\n                if (pos + 1 > $from.pos)\n                    result.push(new SelectionRange($from, $from.doc.resolve(pos + 1)));\n                $from = $from.doc.resolve(pos + 1 + node.content.size);\n                return false;\n            }\n        });\n        if ($from.pos < $to.pos)\n            result.push(new SelectionRange($from, $to));\n    }\n    return result;\n}\n/**\nCreate a command function that toggles the given mark with the\ngiven attributes. Will return `false` when the current selection\ndoesn't support that mark. This will remove the mark if any marks\nof that type exist in the selection, or add it otherwise. If the\nselection is empty, this applies to the [stored\nmarks](https://prosemirror.net/docs/ref/#state.EditorState.storedMarks) instead of a range of the\ndocument.\n*/\nfunction toggleMark(markType, attrs = null, options) {\n    let removeWhenPresent = (options && options.removeWhenPresent) !== false;\n    let enterAtoms = (options && options.enterInlineAtoms) !== false;\n    return function (state, dispatch) {\n        let { empty, $cursor, ranges } = state.selection;\n        if ((empty && !$cursor) || !markApplies(state.doc, ranges, markType, enterAtoms))\n            return false;\n        if (dispatch) {\n            if ($cursor) {\n                if (markType.isInSet(state.storedMarks || $cursor.marks()))\n                    dispatch(state.tr.removeStoredMark(markType));\n                else\n                    dispatch(state.tr.addStoredMark(markType.create(attrs)));\n            }\n            else {\n                let add, tr = state.tr;\n                if (!enterAtoms)\n                    ranges = removeInlineAtoms(ranges);\n                if (removeWhenPresent) {\n                    add = !ranges.some(r => state.doc.rangeHasMark(r.$from.pos, r.$to.pos, markType));\n                }\n                else {\n                    add = !ranges.every(r => {\n                        let missing = false;\n                        tr.doc.nodesBetween(r.$from.pos, r.$to.pos, (node, pos, parent) => {\n                            if (missing)\n                                return false;\n                            missing = !markType.isInSet(node.marks) && !!parent && parent.type.allowsMarkType(markType) &&\n                                !(node.isText && /^\\s*$/.test(node.textBetween(Math.max(0, r.$from.pos - pos), Math.min(node.nodeSize, r.$to.pos - pos))));\n                        });\n                        return !missing;\n                    });\n                }\n                for (let i = 0; i < ranges.length; i++) {\n                    let { $from, $to } = ranges[i];\n                    if (!add) {\n                        tr.removeMark($from.pos, $to.pos, markType);\n                    }\n                    else {\n                        let from = $from.pos, to = $to.pos, start = $from.nodeAfter, end = $to.nodeBefore;\n                        let spaceStart = start && start.isText ? /^\\s*/.exec(start.text)[0].length : 0;\n                        let spaceEnd = end && end.isText ? /\\s*$/.exec(end.text)[0].length : 0;\n                        if (from + spaceStart < to) {\n                            from += spaceStart;\n                            to -= spaceEnd;\n                        }\n                        tr.addMark(from, to, markType.create(attrs));\n                    }\n                }\n                dispatch(tr.scrollIntoView());\n            }\n        }\n        return true;\n    };\n}\nfunction wrapDispatchForJoin(dispatch, isJoinable) {\n    return (tr) => {\n        if (!tr.isGeneric)\n            return dispatch(tr);\n        let ranges = [];\n        for (let i = 0; i < tr.mapping.maps.length; i++) {\n            let map = tr.mapping.maps[i];\n            for (let j = 0; j < ranges.length; j++)\n                ranges[j] = map.map(ranges[j]);\n            map.forEach((_s, _e, from, to) => ranges.push(from, to));\n        }\n        // Figure out which joinable points exist inside those ranges,\n        // by checking all node boundaries in their parent nodes.\n        let joinable = [];\n        for (let i = 0; i < ranges.length; i += 2) {\n            let from = ranges[i], to = ranges[i + 1];\n            let $from = tr.doc.resolve(from), depth = $from.sharedDepth(to), parent = $from.node(depth);\n            for (let index = $from.indexAfter(depth), pos = $from.after(depth + 1); pos <= to; ++index) {\n                let after = parent.maybeChild(index);\n                if (!after)\n                    break;\n                if (index && joinable.indexOf(pos) == -1) {\n                    let before = parent.child(index - 1);\n                    if (before.type == after.type && isJoinable(before, after))\n                        joinable.push(pos);\n                }\n                pos += after.nodeSize;\n            }\n        }\n        // Join the joinable points\n        joinable.sort((a, b) => a - b);\n        for (let i = joinable.length - 1; i >= 0; i--) {\n            if (canJoin(tr.doc, joinable[i]))\n                tr.join(joinable[i]);\n        }\n        dispatch(tr);\n    };\n}\n/**\nWrap a command so that, when it produces a transform that causes\ntwo joinable nodes to end up next to each other, those are joined.\nNodes are considered joinable when they are of the same type and\nwhen the `isJoinable` predicate returns true for them or, if an\narray of strings was passed, if their node type name is in that\narray.\n*/\nfunction autoJoin(command, isJoinable) {\n    let canJoin = Array.isArray(isJoinable) ? (node) => isJoinable.indexOf(node.type.name) > -1\n        : isJoinable;\n    return (state, dispatch, view) => command(state, dispatch && wrapDispatchForJoin(dispatch, canJoin), view);\n}\n/**\nCombine a number of command functions into a single function (which\ncalls them one by one until one returns true).\n*/\nfunction chainCommands(...commands) {\n    return function (state, dispatch, view) {\n        for (let i = 0; i < commands.length; i++)\n            if (commands[i](state, dispatch, view))\n                return true;\n        return false;\n    };\n}\nlet backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);\nlet del = chainCommands(deleteSelection, joinForward, selectNodeForward);\n/**\nA basic keymap containing bindings not specific to any schema.\nBinds the following keys (when multiple commands are listed, they\nare chained with [`chainCommands`](https://prosemirror.net/docs/ref/#commands.chainCommands)):\n\n* **Enter** to `newlineInCode`, `createParagraphNear`, `liftEmptyBlock`, `splitBlock`\n* **Mod-Enter** to `exitCode`\n* **Backspace** and **Mod-Backspace** to `deleteSelection`, `joinBackward`, `selectNodeBackward`\n* **Delete** and **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n* **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n* **Mod-a** to `selectAll`\n*/\nconst pcBaseKeymap = {\n    \"Enter\": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),\n    \"Mod-Enter\": exitCode,\n    \"Backspace\": backspace,\n    \"Mod-Backspace\": backspace,\n    \"Shift-Backspace\": backspace,\n    \"Delete\": del,\n    \"Mod-Delete\": del,\n    \"Mod-a\": selectAll\n};\n/**\nA copy of `pcBaseKeymap` that also binds **Ctrl-h** like Backspace,\n**Ctrl-d** like Delete, **Alt-Backspace** like Ctrl-Backspace, and\n**Ctrl-Alt-Backspace**, **Alt-Delete**, and **Alt-d** like\nCtrl-Delete.\n*/\nconst macBaseKeymap = {\n    \"Ctrl-h\": pcBaseKeymap[\"Backspace\"],\n    \"Alt-Backspace\": pcBaseKeymap[\"Mod-Backspace\"],\n    \"Ctrl-d\": pcBaseKeymap[\"Delete\"],\n    \"Ctrl-Alt-Backspace\": pcBaseKeymap[\"Mod-Delete\"],\n    \"Alt-Delete\": pcBaseKeymap[\"Mod-Delete\"],\n    \"Alt-d\": pcBaseKeymap[\"Mod-Delete\"],\n    \"Ctrl-a\": selectTextblockStart,\n    \"Ctrl-e\": selectTextblockEnd\n};\nfor (let key in pcBaseKeymap)\n    macBaseKeymap[key] = pcBaseKeymap[key];\nconst mac = typeof navigator != \"undefined\" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform)\n    // @ts-ignore\n    : typeof os != \"undefined\" && os.platform ? os.platform() == \"darwin\" : false;\n/**\nDepending on the detected platform, this will hold\n[`pcBasekeymap`](https://prosemirror.net/docs/ref/#commands.pcBaseKeymap) or\n[`macBaseKeymap`](https://prosemirror.net/docs/ref/#commands.macBaseKeymap).\n*/\nconst baseKeymap = mac ? macBaseKeymap : pcBaseKeymap;\n\nexport { autoJoin, baseKeymap, chainCommands, createParagraphNear, deleteSelection, exitCode, joinBackward, joinDown, joinForward, joinTextblockBackward, joinTextblockForward, joinUp, lift, liftEmptyBlock, macBaseKeymap, newlineInCode, pcBaseKeymap, selectAll, selectNodeBackward, selectNodeForward, selectParentNode, selectTextblockEnd, selectTextblockStart, setBlockType, splitBlock, splitBlockAs, splitBlockKeepMarks, toggleMark, wrapIn };\n", "import { Plugin } from 'prosemirror-state';\nimport { dropPoint } from 'prosemirror-transform';\n\n/**\nCreate a plugin that, when added to a ProseMirror instance,\ncauses a decoration to show up at the drop position when something\nis dragged over the editor.\n\nNodes may add a `disableDropCursor` property to their spec to\ncontrol the showing of a drop cursor inside them. This may be a\nboolean or a function, which will be called with a view and a\nposition, and should return a boolean.\n*/\nfunction dropCursor(options = {}) {\n    return new Plugin({\n        view(editorView) { return new DropCursorView(editorView, options); }\n    });\n}\nclass DropCursorView {\n    constructor(editorView, options) {\n        var _a;\n        this.editorView = editorView;\n        this.cursorPos = null;\n        this.element = null;\n        this.timeout = -1;\n        this.width = (_a = options.width) !== null && _a !== void 0 ? _a : 1;\n        this.color = options.color === false ? undefined : (options.color || \"black\");\n        this.class = options.class;\n        this.handlers = [\"dragover\", \"dragend\", \"drop\", \"dragleave\"].map(name => {\n            let handler = (e) => { this[name](e); };\n            editorView.dom.addEventListener(name, handler);\n            return { name, handler };\n        });\n    }\n    destroy() {\n        this.handlers.forEach(({ name, handler }) => this.editorView.dom.removeEventListener(name, handler));\n    }\n    update(editorView, prevState) {\n        if (this.cursorPos != null && prevState.doc != editorView.state.doc) {\n            if (this.cursorPos > editorView.state.doc.content.size)\n                this.setCursor(null);\n            else\n                this.updateOverlay();\n        }\n    }\n    setCursor(pos) {\n        if (pos == this.cursorPos)\n            return;\n        this.cursorPos = pos;\n        if (pos == null) {\n            this.element.parentNode.removeChild(this.element);\n            this.element = null;\n        }\n        else {\n            this.updateOverlay();\n        }\n    }\n    updateOverlay() {\n        let $pos = this.editorView.state.doc.resolve(this.cursorPos);\n        let isBlock = !$pos.parent.inlineContent, rect;\n        if (isBlock) {\n            let before = $pos.nodeBefore, after = $pos.nodeAfter;\n            if (before || after) {\n                let node = this.editorView.nodeDOM(this.cursorPos - (before ? before.nodeSize : 0));\n                if (node) {\n                    let nodeRect = node.getBoundingClientRect();\n                    let top = before ? nodeRect.bottom : nodeRect.top;\n                    if (before && after)\n                        top = (top + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2;\n                    rect = { left: nodeRect.left, right: nodeRect.right, top: top - this.width / 2, bottom: top + this.width / 2 };\n                }\n            }\n        }\n        if (!rect) {\n            let coords = this.editorView.coordsAtPos(this.cursorPos);\n            rect = { left: coords.left - this.width / 2, right: coords.left + this.width / 2, top: coords.top, bottom: coords.bottom };\n        }\n        let parent = this.editorView.dom.offsetParent;\n        if (!this.element) {\n            this.element = parent.appendChild(document.createElement(\"div\"));\n            if (this.class)\n                this.element.className = this.class;\n            this.element.style.cssText = \"position: absolute; z-index: 50; pointer-events: none;\";\n            if (this.color) {\n                this.element.style.backgroundColor = this.color;\n            }\n        }\n        this.element.classList.toggle(\"prosemirror-dropcursor-block\", isBlock);\n        this.element.classList.toggle(\"prosemirror-dropcursor-inline\", !isBlock);\n        let parentLeft, parentTop;\n        if (!parent || parent == document.body && getComputedStyle(parent).position == \"static\") {\n            parentLeft = -pageXOffset;\n            parentTop = -pageYOffset;\n        }\n        else {\n            let rect = parent.getBoundingClientRect();\n            parentLeft = rect.left - parent.scrollLeft;\n            parentTop = rect.top - parent.scrollTop;\n        }\n        this.element.style.left = (rect.left - parentLeft) + \"px\";\n        this.element.style.top = (rect.top - parentTop) + \"px\";\n        this.element.style.width = (rect.right - rect.left) + \"px\";\n        this.element.style.height = (rect.bottom - rect.top) + \"px\";\n    }\n    scheduleRemoval(timeout) {\n        clearTimeout(this.timeout);\n        this.timeout = setTimeout(() => this.setCursor(null), timeout);\n    }\n    dragover(event) {\n        if (!this.editorView.editable)\n            return;\n        let pos = this.editorView.posAtCoords({ left: event.clientX, top: event.clientY });\n        let node = pos && pos.inside >= 0 && this.editorView.state.doc.nodeAt(pos.inside);\n        let disableDropCursor = node && node.type.spec.disableDropCursor;\n        let disabled = typeof disableDropCursor == \"function\" ? disableDropCursor(this.editorView, pos, event) : disableDropCursor;\n        if (pos && !disabled) {\n            let target = pos.pos;\n            if (this.editorView.dragging && this.editorView.dragging.slice) {\n                let point = dropPoint(this.editorView.state.doc, target, this.editorView.dragging.slice);\n                if (point != null)\n                    target = point;\n            }\n            this.setCursor(target);\n            this.scheduleRemoval(5000);\n        }\n    }\n    dragend() {\n        this.scheduleRemoval(20);\n    }\n    drop() {\n        this.scheduleRemoval(20);\n    }\n    dragleave(event) {\n        if (event.target == this.editorView.dom || !this.editorView.dom.contains(event.relatedTarget))\n            this.setCursor(null);\n    }\n}\n\nexport { dropCursor };\n", "import { keydownHandler } from 'prosemirror-keymap';\nimport { Selection, NodeSelection, TextSelection, Plugin } from 'prosemirror-state';\nimport { Slice, Fragment } from 'prosemirror-model';\nimport { DecorationSet, Decoration } from 'prosemirror-view';\n\n/**\nGap cursor selections are represented using this class. Its\n`$anchor` and `$head` properties both point at the cursor position.\n*/\nclass GapCursor extends Selection {\n    /**\n    Create a gap cursor.\n    */\n    constructor($pos) {\n        super($pos, $pos);\n    }\n    map(doc, mapping) {\n        let $pos = doc.resolve(mapping.map(this.head));\n        return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);\n    }\n    content() { return Slice.empty; }\n    eq(other) {\n        return other instanceof GapCursor && other.head == this.head;\n    }\n    toJSON() {\n        return { type: \"gapcursor\", pos: this.head };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(doc, json) {\n        if (typeof json.pos != \"number\")\n            throw new RangeError(\"Invalid input for GapCursor.fromJSON\");\n        return new GapCursor(doc.resolve(json.pos));\n    }\n    /**\n    @internal\n    */\n    getBookmark() { return new GapBookmark(this.anchor); }\n    /**\n    @internal\n    */\n    static valid($pos) {\n        let parent = $pos.parent;\n        if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos))\n            return false;\n        let override = parent.type.spec.allowGapCursor;\n        if (override != null)\n            return override;\n        let deflt = parent.contentMatchAt($pos.index()).defaultType;\n        return deflt && deflt.isTextblock;\n    }\n    /**\n    @internal\n    */\n    static findGapCursorFrom($pos, dir, mustMove = false) {\n        search: for (;;) {\n            if (!mustMove && GapCursor.valid($pos))\n                return $pos;\n            let pos = $pos.pos, next = null;\n            // Scan up from this position\n            for (let d = $pos.depth;; d--) {\n                let parent = $pos.node(d);\n                if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {\n                    next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);\n                    break;\n                }\n                else if (d == 0) {\n                    return null;\n                }\n                pos += dir;\n                let $cur = $pos.doc.resolve(pos);\n                if (GapCursor.valid($cur))\n                    return $cur;\n            }\n            // And then down into the next node\n            for (;;) {\n                let inside = dir > 0 ? next.firstChild : next.lastChild;\n                if (!inside) {\n                    if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {\n                        $pos = $pos.doc.resolve(pos + next.nodeSize * dir);\n                        mustMove = false;\n                        continue search;\n                    }\n                    break;\n                }\n                next = inside;\n                pos += dir;\n                let $cur = $pos.doc.resolve(pos);\n                if (GapCursor.valid($cur))\n                    return $cur;\n            }\n            return null;\n        }\n    }\n}\nGapCursor.prototype.visible = false;\nGapCursor.findFrom = GapCursor.findGapCursorFrom;\nSelection.jsonID(\"gapcursor\", GapCursor);\nclass GapBookmark {\n    constructor(pos) {\n        this.pos = pos;\n    }\n    map(mapping) {\n        return new GapBookmark(mapping.map(this.pos));\n    }\n    resolve(doc) {\n        let $pos = doc.resolve(this.pos);\n        return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);\n    }\n}\nfunction closedBefore($pos) {\n    for (let d = $pos.depth; d >= 0; d--) {\n        let index = $pos.index(d), parent = $pos.node(d);\n        // At the start of this parent, look at next one\n        if (index == 0) {\n            if (parent.type.spec.isolating)\n                return true;\n            continue;\n        }\n        // See if the node before (or its first ancestor) is closed\n        for (let before = parent.child(index - 1);; before = before.lastChild) {\n            if ((before.childCount == 0 && !before.inlineContent) || before.isAtom || before.type.spec.isolating)\n                return true;\n            if (before.inlineContent)\n                return false;\n        }\n    }\n    // Hit start of document\n    return true;\n}\nfunction closedAfter($pos) {\n    for (let d = $pos.depth; d >= 0; d--) {\n        let index = $pos.indexAfter(d), parent = $pos.node(d);\n        if (index == parent.childCount) {\n            if (parent.type.spec.isolating)\n                return true;\n            continue;\n        }\n        for (let after = parent.child(index);; after = after.firstChild) {\n            if ((after.childCount == 0 && !after.inlineContent) || after.isAtom || after.type.spec.isolating)\n                return true;\n            if (after.inlineContent)\n                return false;\n        }\n    }\n    return true;\n}\n\n/**\nCreate a gap cursor plugin. When enabled, this will capture clicks\nnear and arrow-key-motion past places that don't have a normally\nselectable position nearby, and create a gap cursor selection for\nthem. The cursor is drawn as an element with class\n`ProseMirror-gapcursor`. You can either include\n`style/gapcursor.css` from the package's directory or add your own\nstyles to make it visible.\n*/\nfunction gapCursor() {\n    return new Plugin({\n        props: {\n            decorations: drawGapCursor,\n            createSelectionBetween(_view, $anchor, $head) {\n                return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;\n            },\n            handleClick,\n            handleKeyDown,\n            handleDOMEvents: { beforeinput: beforeinput }\n        }\n    });\n}\nconst handleKeyDown = keydownHandler({\n    \"ArrowLeft\": arrow(\"horiz\", -1),\n    \"ArrowRight\": arrow(\"horiz\", 1),\n    \"ArrowUp\": arrow(\"vert\", -1),\n    \"ArrowDown\": arrow(\"vert\", 1)\n});\nfunction arrow(axis, dir) {\n    const dirStr = axis == \"vert\" ? (dir > 0 ? \"down\" : \"up\") : (dir > 0 ? \"right\" : \"left\");\n    return function (state, dispatch, view) {\n        let sel = state.selection;\n        let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;\n        if (sel instanceof TextSelection) {\n            if (!view.endOfTextblock(dirStr) || $start.depth == 0)\n                return false;\n            mustMove = false;\n            $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());\n        }\n        let $found = GapCursor.findGapCursorFrom($start, dir, mustMove);\n        if (!$found)\n            return false;\n        if (dispatch)\n            dispatch(state.tr.setSelection(new GapCursor($found)));\n        return true;\n    };\n}\nfunction handleClick(view, pos, event) {\n    if (!view || !view.editable)\n        return false;\n    let $pos = view.state.doc.resolve(pos);\n    if (!GapCursor.valid($pos))\n        return false;\n    let clickPos = view.posAtCoords({ left: event.clientX, top: event.clientY });\n    if (clickPos && clickPos.inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside)))\n        return false;\n    view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));\n    return true;\n}\n// This is a hack that, when a composition starts while a gap cursor\n// is active, quickly creates an inline context for the composition to\n// happen in, to avoid it being aborted by the DOM selection being\n// moved into a valid position.\nfunction beforeinput(view, event) {\n    if (event.inputType != \"insertCompositionText\" || !(view.state.selection instanceof GapCursor))\n        return false;\n    let { $from } = view.state.selection;\n    let insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);\n    if (!insert)\n        return false;\n    let frag = Fragment.empty;\n    for (let i = insert.length - 1; i >= 0; i--)\n        frag = Fragment.from(insert[i].createAndFill(null, frag));\n    let tr = view.state.tr.replace($from.pos, $from.pos, new Slice(frag, 0, 0));\n    tr.setSelection(TextSelection.near(tr.doc.resolve($from.pos + 1)));\n    view.dispatch(tr);\n    return false;\n}\nfunction drawGapCursor(state) {\n    if (!(state.selection instanceof GapCursor))\n        return null;\n    let node = document.createElement(\"div\");\n    node.className = \"ProseMirror-gapcursor\";\n    return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node, { key: \"gapcursor\" })]);\n}\n\nexport { GapCursor, gapCursor };\n", "export default function crelt() {\n  var elt = arguments[0]\n  if (typeof elt == \"string\") elt = document.createElement(elt)\n  var i = 1, next = arguments[1]\n  if (next && typeof next == \"object\" && next.nodeType == null && !Array.isArray(next)) {\n    for (var name in next) if (Object.prototype.hasOwnProperty.call(next, name)) {\n      var value = next[name]\n      if (typeof value == \"string\") elt.setAttribute(name, value)\n      else if (value != null) elt[name] = value\n    }\n    i++\n  }\n  for (; i < arguments.length; i++) add(elt, arguments[i])\n  return elt\n}\n\nfunction add(elt, child) {\n  if (typeof child == \"string\") {\n    elt.appendChild(document.createTextNode(child))\n  } else if (child == null) {\n  } else if (child.nodeType != null) {\n    elt.appendChild(child)\n  } else if (Array.isArray(child)) {\n    for (var i = 0; i < child.length; i++) add(elt, child[i])\n  } else {\n    throw new RangeError(\"Unsupported child node: \" + child)\n  }\n}\n", "import crel from 'crelt';\nimport { joinUp, lift, selectParentNode, setBlockType, wrapIn } from 'prosemirror-commands';\nimport { undo, redo } from 'prosemirror-history';\nimport { Plugin } from 'prosemirror-state';\n\nconst SVG = \"http://www.w3.org/2000/svg\";\nconst XLINK = \"http://www.w3.org/1999/xlink\";\nconst prefix$2 = \"ProseMirror-icon\";\nfunction hashPath(path) {\n    let hash = 0;\n    for (let i = 0; i < path.length; i++)\n        hash = (((hash << 5) - hash) + path.charCodeAt(i)) | 0;\n    return hash;\n}\nfunction getIcon(root, icon) {\n    let doc = (root.nodeType == 9 ? root : root.ownerDocument) || document;\n    let node = doc.createElement(\"div\");\n    node.className = prefix$2;\n    if (icon.path) {\n        let { path, width, height } = icon;\n        let name = \"pm-icon-\" + hashPath(path).toString(16);\n        if (!doc.getElementById(name))\n            buildSVG(root, name, icon);\n        let svg = node.appendChild(doc.createElementNS(SVG, \"svg\"));\n        svg.style.width = (width / height) + \"em\";\n        let use = svg.appendChild(doc.createElementNS(SVG, \"use\"));\n        use.setAttributeNS(XLINK, \"href\", /([^#]*)/.exec(doc.location.toString())[1] + \"#\" + name);\n    }\n    else if (icon.dom) {\n        node.appendChild(icon.dom.cloneNode(true));\n    }\n    else {\n        let { text, css } = icon;\n        node.appendChild(doc.createElement(\"span\")).textContent = text || '';\n        if (css)\n            node.firstChild.style.cssText = css;\n    }\n    return node;\n}\nfunction buildSVG(root, name, data) {\n    let [doc, top] = root.nodeType == 9 ? [root, root.body] : [root.ownerDocument || document, root];\n    let collection = doc.getElementById(prefix$2 + \"-collection\");\n    if (!collection) {\n        collection = doc.createElementNS(SVG, \"svg\");\n        collection.id = prefix$2 + \"-collection\";\n        collection.style.display = \"none\";\n        top.insertBefore(collection, top.firstChild);\n    }\n    let sym = doc.createElementNS(SVG, \"symbol\");\n    sym.id = name;\n    sym.setAttribute(\"viewBox\", \"0 0 \" + data.width + \" \" + data.height);\n    let path = sym.appendChild(doc.createElementNS(SVG, \"path\"));\n    path.setAttribute(\"d\", data.path);\n    collection.appendChild(sym);\n}\n\nconst prefix$1 = \"ProseMirror-menu\";\n/**\nAn icon or label that, when clicked, executes a command.\n*/\nclass MenuItem {\n    /**\n    Create a menu item.\n    */\n    constructor(\n    /**\n    The spec used to create this item.\n    */\n    spec) {\n        this.spec = spec;\n    }\n    /**\n    Renders the icon according to its [display\n    spec](https://prosemirror.net/docs/ref/#menu.MenuItemSpec.display), and adds an event handler which\n    executes the command when the representation is clicked.\n    */\n    render(view) {\n        let spec = this.spec;\n        let dom = spec.render ? spec.render(view)\n            : spec.icon ? getIcon(view.root, spec.icon)\n                : spec.label ? crel(\"div\", null, translate(view, spec.label))\n                    : null;\n        if (!dom)\n            throw new RangeError(\"MenuItem without icon or label property\");\n        if (spec.title) {\n            const title = (typeof spec.title === \"function\" ? spec.title(view.state) : spec.title);\n            dom.setAttribute(\"title\", translate(view, title));\n        }\n        if (spec.class)\n            dom.classList.add(spec.class);\n        if (spec.css)\n            dom.style.cssText += spec.css;\n        dom.addEventListener(\"mousedown\", e => {\n            e.preventDefault();\n            if (!dom.classList.contains(prefix$1 + \"-disabled\"))\n                spec.run(view.state, view.dispatch, view, e);\n        });\n        function update(state) {\n            if (spec.select) {\n                let selected = spec.select(state);\n                dom.style.display = selected ? \"\" : \"none\";\n                if (!selected)\n                    return false;\n            }\n            let enabled = true;\n            if (spec.enable) {\n                enabled = spec.enable(state) || false;\n                setClass(dom, prefix$1 + \"-disabled\", !enabled);\n            }\n            if (spec.active) {\n                let active = enabled && spec.active(state) || false;\n                setClass(dom, prefix$1 + \"-active\", active);\n            }\n            return true;\n        }\n        return { dom, update };\n    }\n}\nfunction translate(view, text) {\n    return view._props.translate ? view._props.translate(text) : text;\n}\nlet lastMenuEvent = { time: 0, node: null };\nfunction markMenuEvent(e) {\n    lastMenuEvent.time = Date.now();\n    lastMenuEvent.node = e.target;\n}\nfunction isMenuEvent(wrapper) {\n    return Date.now() - 100 < lastMenuEvent.time &&\n        lastMenuEvent.node && wrapper.contains(lastMenuEvent.node);\n}\n/**\nA drop-down menu, displayed as a label with a downwards-pointing\ntriangle to the right of it.\n*/\nclass Dropdown {\n    /**\n    Create a dropdown wrapping the elements.\n    */\n    constructor(content, \n    /**\n    @internal\n    */\n    options = {}) {\n        this.options = options;\n        this.options = options || {};\n        this.content = Array.isArray(content) ? content : [content];\n    }\n    /**\n    Render the dropdown menu and sub-items.\n    */\n    render(view) {\n        let content = renderDropdownItems(this.content, view);\n        let win = view.dom.ownerDocument.defaultView || window;\n        let label = crel(\"div\", { class: prefix$1 + \"-dropdown \" + (this.options.class || \"\"),\n            style: this.options.css }, translate(view, this.options.label || \"\"));\n        if (this.options.title)\n            label.setAttribute(\"title\", translate(view, this.options.title));\n        let wrap = crel(\"div\", { class: prefix$1 + \"-dropdown-wrap\" }, label);\n        let open = null;\n        let listeningOnClose = null;\n        let close = () => {\n            if (open && open.close()) {\n                open = null;\n                win.removeEventListener(\"mousedown\", listeningOnClose);\n            }\n        };\n        label.addEventListener(\"mousedown\", e => {\n            e.preventDefault();\n            markMenuEvent(e);\n            if (open) {\n                close();\n            }\n            else {\n                open = this.expand(wrap, content.dom);\n                win.addEventListener(\"mousedown\", listeningOnClose = () => {\n                    if (!isMenuEvent(wrap))\n                        close();\n                });\n            }\n        });\n        function update(state) {\n            let inner = content.update(state);\n            wrap.style.display = inner ? \"\" : \"none\";\n            return inner;\n        }\n        return { dom: wrap, update };\n    }\n    /**\n    @internal\n    */\n    expand(dom, items) {\n        let menuDOM = crel(\"div\", { class: prefix$1 + \"-dropdown-menu \" + (this.options.class || \"\") }, items);\n        let done = false;\n        function close() {\n            if (done)\n                return false;\n            done = true;\n            dom.removeChild(menuDOM);\n            return true;\n        }\n        dom.appendChild(menuDOM);\n        return { close, node: menuDOM };\n    }\n}\nfunction renderDropdownItems(items, view) {\n    let rendered = [], updates = [];\n    for (let i = 0; i < items.length; i++) {\n        let { dom, update } = items[i].render(view);\n        rendered.push(crel(\"div\", { class: prefix$1 + \"-dropdown-item\" }, dom));\n        updates.push(update);\n    }\n    return { dom: rendered, update: combineUpdates(updates, rendered) };\n}\nfunction combineUpdates(updates, nodes) {\n    return (state) => {\n        let something = false;\n        for (let i = 0; i < updates.length; i++) {\n            let up = updates[i](state);\n            nodes[i].style.display = up ? \"\" : \"none\";\n            if (up)\n                something = true;\n        }\n        return something;\n    };\n}\n/**\nRepresents a submenu wrapping a group of elements that start\nhidden and expand to the right when hovered over or tapped.\n*/\nclass DropdownSubmenu {\n    /**\n    Creates a submenu for the given group of menu elements. The\n    following options are recognized:\n    */\n    constructor(content, \n    /**\n    @internal\n    */\n    options = {}) {\n        this.options = options;\n        this.content = Array.isArray(content) ? content : [content];\n    }\n    /**\n    Renders the submenu.\n    */\n    render(view) {\n        let items = renderDropdownItems(this.content, view);\n        let win = view.dom.ownerDocument.defaultView || window;\n        let label = crel(\"div\", { class: prefix$1 + \"-submenu-label\" }, translate(view, this.options.label || \"\"));\n        let wrap = crel(\"div\", { class: prefix$1 + \"-submenu-wrap\" }, label, crel(\"div\", { class: prefix$1 + \"-submenu\" }, items.dom));\n        let listeningOnClose = null;\n        label.addEventListener(\"mousedown\", e => {\n            e.preventDefault();\n            markMenuEvent(e);\n            setClass(wrap, prefix$1 + \"-submenu-wrap-active\", false);\n            if (!listeningOnClose)\n                win.addEventListener(\"mousedown\", listeningOnClose = () => {\n                    if (!isMenuEvent(wrap)) {\n                        wrap.classList.remove(prefix$1 + \"-submenu-wrap-active\");\n                        win.removeEventListener(\"mousedown\", listeningOnClose);\n                        listeningOnClose = null;\n                    }\n                });\n        });\n        function update(state) {\n            let inner = items.update(state);\n            wrap.style.display = inner ? \"\" : \"none\";\n            return inner;\n        }\n        return { dom: wrap, update };\n    }\n}\n/**\nRender the given, possibly nested, array of menu elements into a\ndocument fragment, placing separators between them (and ensuring no\nsuperfluous separators appear when some of the groups turn out to\nbe empty).\n*/\nfunction renderGrouped(view, content) {\n    let result = document.createDocumentFragment();\n    let updates = [], separators = [];\n    for (let i = 0; i < content.length; i++) {\n        let items = content[i], localUpdates = [], localNodes = [];\n        for (let j = 0; j < items.length; j++) {\n            let { dom, update } = items[j].render(view);\n            let span = crel(\"span\", { class: prefix$1 + \"item\" }, dom);\n            result.appendChild(span);\n            localNodes.push(span);\n            localUpdates.push(update);\n        }\n        if (localUpdates.length) {\n            updates.push(combineUpdates(localUpdates, localNodes));\n            if (i < content.length - 1)\n                separators.push(result.appendChild(separator()));\n        }\n    }\n    function update(state) {\n        let something = false, needSep = false;\n        for (let i = 0; i < updates.length; i++) {\n            let hasContent = updates[i](state);\n            if (i)\n                separators[i - 1].style.display = needSep && hasContent ? \"\" : \"none\";\n            needSep = hasContent;\n            if (hasContent)\n                something = true;\n        }\n        return something;\n    }\n    return { dom: result, update };\n}\nfunction separator() {\n    return crel(\"span\", { class: prefix$1 + \"separator\" });\n}\n/**\nA set of basic editor-related icons. Contains the properties\n`join`, `lift`, `selectParentNode`, `undo`, `redo`, `strong`, `em`,\n`code`, `link`, `bulletList`, `orderedList`, and `blockquote`, each\nholding an object that can be used as the `icon` option to\n`MenuItem`.\n*/\nconst icons = {\n    join: {\n        width: 800, height: 900,\n        path: \"M0 75h800v125h-800z M0 825h800v-125h-800z M250 400h100v-100h100v100h100v100h-100v100h-100v-100h-100z\"\n    },\n    lift: {\n        width: 1024, height: 1024,\n        path: \"M219 310v329q0 7-5 12t-12 5q-8 0-13-5l-164-164q-5-5-5-13t5-13l164-164q5-5 13-5 7 0 12 5t5 12zM1024 749v109q0 7-5 12t-12 5h-987q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h987q7 0 12 5t5 12zM1024 530v109q0 7-5 12t-12 5h-621q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h621q7 0 12 5t5 12zM1024 310v109q0 7-5 12t-12 5h-621q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h621q7 0 12 5t5 12zM1024 91v109q0 7-5 12t-12 5h-987q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h987q7 0 12 5t5 12z\"\n    },\n    selectParentNode: { text: \"\\u2b1a\", css: \"font-weight: bold\" },\n    undo: {\n        width: 1024, height: 1024,\n        path: \"M761 1024c113-206 132-520-313-509v253l-384-384 384-384v248c534-13 594 472 313 775z\"\n    },\n    redo: {\n        width: 1024, height: 1024,\n        path: \"M576 248v-248l384 384-384 384v-253c-446-10-427 303-313 509-280-303-221-789 313-775z\"\n    },\n    strong: {\n        width: 805, height: 1024,\n        path: \"M317 869q42 18 80 18 214 0 214-191 0-65-23-102-15-25-35-42t-38-26-46-14-48-6-54-1q-41 0-57 5 0 30-0 90t-0 90q0 4-0 38t-0 55 2 47 6 38zM309 442q24 4 62 4 46 0 81-7t62-25 42-51 14-81q0-40-16-70t-45-46-61-24-70-8q-28 0-74 7 0 28 2 86t2 86q0 15-0 45t-0 45q0 26 0 39zM0 950l1-53q8-2 48-9t60-15q4-6 7-15t4-19 3-18 1-21 0-19v-37q0-561-12-585-2-4-12-8t-25-6-28-4-27-2-17-1l-2-47q56-1 194-6t213-5q13 0 39 0t38 0q40 0 78 7t73 24 61 40 42 59 16 78q0 29-9 54t-22 41-36 32-41 25-48 22q88 20 146 76t58 141q0 57-20 102t-53 74-78 48-93 27-100 8q-25 0-75-1t-75-1q-60 0-175 6t-132 6z\"\n    },\n    em: {\n        width: 585, height: 1024,\n        path: \"M0 949l9-48q3-1 46-12t63-21q16-20 23-57 0-4 35-165t65-310 29-169v-14q-13-7-31-10t-39-4-33-3l10-58q18 1 68 3t85 4 68 1q27 0 56-1t69-4 56-3q-2 22-10 50-17 5-58 16t-62 19q-4 10-8 24t-5 22-4 26-3 24q-15 84-50 239t-44 203q-1 5-7 33t-11 51-9 47-3 32l0 10q9 2 105 17-1 25-9 56-6 0-18 0t-18 0q-16 0-49-5t-49-5q-78-1-117-1-29 0-81 5t-69 6z\"\n    },\n    code: {\n        width: 896, height: 1024,\n        path: \"M608 192l-96 96 224 224-224 224 96 96 288-320-288-320zM288 192l-288 320 288 320 96-96-224-224 224-224-96-96z\"\n    },\n    link: {\n        width: 951, height: 1024,\n        path: \"M832 694q0-22-16-38l-118-118q-16-16-38-16-24 0-41 18 1 1 10 10t12 12 8 10 7 14 2 15q0 22-16 38t-38 16q-8 0-15-2t-14-7-10-8-12-12-10-10q-18 17-18 41 0 22 16 38l117 118q15 15 38 15 22 0 38-14l84-83q16-16 16-38zM430 292q0-22-16-38l-117-118q-16-16-38-16-22 0-38 15l-84 83q-16 16-16 38 0 22 16 38l118 118q15 15 38 15 24 0 41-17-1-1-10-10t-12-12-8-10-7-14-2-15q0-22 16-38t38-16q8 0 15 2t14 7 10 8 12 12 10 10q18-17 18-41zM941 694q0 68-48 116l-84 83q-47 47-116 47-69 0-116-48l-117-118q-47-47-47-116 0-70 50-119l-50-50q-49 50-118 50-68 0-116-48l-118-118q-48-48-48-116t48-116l84-83q47-47 116-47 69 0 116 48l117 118q47 47 47 116 0 70-50 119l50 50q49-50 118-50 68 0 116 48l118 118q48 48 48 116z\"\n    },\n    bulletList: {\n        width: 768, height: 896,\n        path: \"M0 512h128v-128h-128v128zM0 256h128v-128h-128v128zM0 768h128v-128h-128v128zM256 512h512v-128h-512v128zM256 256h512v-128h-512v128zM256 768h512v-128h-512v128z\"\n    },\n    orderedList: {\n        width: 768, height: 896,\n        path: \"M320 512h448v-128h-448v128zM320 768h448v-128h-448v128zM320 128v128h448v-128h-448zM79 384h78v-256h-36l-85 23v50l43-2v185zM189 590c0-36-12-78-96-78-33 0-64 6-83 16l1 66c21-10 42-15 67-15s32 11 32 28c0 26-30 58-110 112v50h192v-67l-91 2c49-30 87-66 87-113l1-1z\"\n    },\n    blockquote: {\n        width: 640, height: 896,\n        path: \"M0 448v256h256v-256h-128c0 0 0-128 128-128v-128c0 0-256 0-256 256zM640 320v-128c0 0-256 0-256 256v256h256v-256h-128c0 0 0-128 128-128z\"\n    }\n};\n/**\nMenu item for the `joinUp` command.\n*/\nconst joinUpItem = new MenuItem({\n    title: \"Join with above block\",\n    run: joinUp,\n    select: state => joinUp(state),\n    icon: icons.join\n});\n/**\nMenu item for the `lift` command.\n*/\nconst liftItem = new MenuItem({\n    title: \"Lift out of enclosing block\",\n    run: lift,\n    select: state => lift(state),\n    icon: icons.lift\n});\n/**\nMenu item for the `selectParentNode` command.\n*/\nconst selectParentNodeItem = new MenuItem({\n    title: \"Select parent node\",\n    run: selectParentNode,\n    select: state => selectParentNode(state),\n    icon: icons.selectParentNode\n});\n/**\nMenu item for the `undo` command.\n*/\nlet undoItem = new MenuItem({\n    title: \"Undo last change\",\n    run: undo,\n    enable: state => undo(state),\n    icon: icons.undo\n});\n/**\nMenu item for the `redo` command.\n*/\nlet redoItem = new MenuItem({\n    title: \"Redo last undone change\",\n    run: redo,\n    enable: state => redo(state),\n    icon: icons.redo\n});\n/**\nBuild a menu item for wrapping the selection in a given node type.\nAdds `run` and `select` properties to the ones present in\n`options`. `options.attrs` may be an object that provides\nattributes for the wrapping node.\n*/\nfunction wrapItem(nodeType, options) {\n    let passedOptions = {\n        run(state, dispatch) {\n            return wrapIn(nodeType, options.attrs)(state, dispatch);\n        },\n        select(state) {\n            return wrapIn(nodeType, options.attrs)(state);\n        }\n    };\n    for (let prop in options)\n        passedOptions[prop] = options[prop];\n    return new MenuItem(passedOptions);\n}\n/**\nBuild a menu item for changing the type of the textblock around the\nselection to the given type. Provides `run`, `active`, and `select`\nproperties. Others must be given in `options`. `options.attrs` may\nbe an object to provide the attributes for the textblock node.\n*/\nfunction blockTypeItem(nodeType, options) {\n    let command = setBlockType(nodeType, options.attrs);\n    let passedOptions = {\n        run: command,\n        enable(state) { return command(state); },\n        active(state) {\n            let { $from, to, node } = state.selection;\n            if (node)\n                return node.hasMarkup(nodeType, options.attrs);\n            return to <= $from.end() && $from.parent.hasMarkup(nodeType, options.attrs);\n        }\n    };\n    for (let prop in options)\n        passedOptions[prop] = options[prop];\n    return new MenuItem(passedOptions);\n}\n// Work around classList.toggle being broken in IE11\nfunction setClass(dom, cls, on) {\n    if (on)\n        dom.classList.add(cls);\n    else\n        dom.classList.remove(cls);\n}\n\nconst prefix = \"ProseMirror-menubar\";\nfunction isIOS() {\n    if (typeof navigator == \"undefined\")\n        return false;\n    let agent = navigator.userAgent;\n    return !/Edge\\/\\d/.test(agent) && /AppleWebKit/.test(agent) && /Mobile\\/\\w+/.test(agent);\n}\n/**\nA plugin that will place a menu bar above the editor. Note that\nthis involves wrapping the editor in an additional `<div>`.\n*/\nfunction menuBar(options) {\n    return new Plugin({\n        view(editorView) { return new MenuBarView(editorView, options); }\n    });\n}\nclass MenuBarView {\n    constructor(editorView, options) {\n        this.editorView = editorView;\n        this.options = options;\n        this.spacer = null;\n        this.maxHeight = 0;\n        this.widthForMaxHeight = 0;\n        this.floating = false;\n        this.scrollHandler = null;\n        this.wrapper = crel(\"div\", { class: prefix + \"-wrapper\" });\n        this.menu = this.wrapper.appendChild(crel(\"div\", { class: prefix }));\n        this.menu.className = prefix;\n        if (editorView.dom.parentNode)\n            editorView.dom.parentNode.replaceChild(this.wrapper, editorView.dom);\n        this.wrapper.appendChild(editorView.dom);\n        let { dom, update } = renderGrouped(this.editorView, this.options.content);\n        this.contentUpdate = update;\n        this.menu.appendChild(dom);\n        this.update();\n        if (options.floating && !isIOS()) {\n            this.updateFloat();\n            let potentialScrollers = getAllWrapping(this.wrapper);\n            this.scrollHandler = (e) => {\n                let root = this.editorView.root;\n                if (!(root.body || root).contains(this.wrapper))\n                    potentialScrollers.forEach(el => el.removeEventListener(\"scroll\", this.scrollHandler));\n                else\n                    this.updateFloat(e.target.getBoundingClientRect ? e.target : undefined);\n            };\n            potentialScrollers.forEach(el => el.addEventListener('scroll', this.scrollHandler));\n        }\n    }\n    update() {\n        this.contentUpdate(this.editorView.state);\n        if (this.floating) {\n            this.updateScrollCursor();\n        }\n        else {\n            if (this.menu.offsetWidth != this.widthForMaxHeight) {\n                this.widthForMaxHeight = this.menu.offsetWidth;\n                this.maxHeight = 0;\n            }\n            if (this.menu.offsetHeight > this.maxHeight) {\n                this.maxHeight = this.menu.offsetHeight;\n                this.menu.style.minHeight = this.maxHeight + \"px\";\n            }\n        }\n    }\n    updateScrollCursor() {\n        let selection = this.editorView.root.getSelection();\n        if (!selection.focusNode)\n            return;\n        let rects = selection.getRangeAt(0).getClientRects();\n        let selRect = rects[selectionIsInverted(selection) ? 0 : rects.length - 1];\n        if (!selRect)\n            return;\n        let menuRect = this.menu.getBoundingClientRect();\n        if (selRect.top < menuRect.bottom && selRect.bottom > menuRect.top) {\n            let scrollable = findWrappingScrollable(this.wrapper);\n            if (scrollable)\n                scrollable.scrollTop -= (menuRect.bottom - selRect.top);\n        }\n    }\n    updateFloat(scrollAncestor) {\n        let parent = this.wrapper, editorRect = parent.getBoundingClientRect(), top = scrollAncestor ? Math.max(0, scrollAncestor.getBoundingClientRect().top) : 0;\n        if (this.floating) {\n            if (editorRect.top >= top || editorRect.bottom < this.menu.offsetHeight + 10) {\n                this.floating = false;\n                this.menu.style.position = this.menu.style.left = this.menu.style.top = this.menu.style.width = \"\";\n                this.menu.style.display = \"\";\n                this.spacer.parentNode.removeChild(this.spacer);\n                this.spacer = null;\n            }\n            else {\n                let border = (parent.offsetWidth - parent.clientWidth) / 2;\n                this.menu.style.left = (editorRect.left + border) + \"px\";\n                this.menu.style.display = editorRect.top > (this.editorView.dom.ownerDocument.defaultView || window).innerHeight\n                    ? \"none\" : \"\";\n                if (scrollAncestor)\n                    this.menu.style.top = top + \"px\";\n            }\n        }\n        else {\n            if (editorRect.top < top && editorRect.bottom >= this.menu.offsetHeight + 10) {\n                this.floating = true;\n                let menuRect = this.menu.getBoundingClientRect();\n                this.menu.style.left = menuRect.left + \"px\";\n                this.menu.style.width = menuRect.width + \"px\";\n                if (scrollAncestor)\n                    this.menu.style.top = top + \"px\";\n                this.menu.style.position = \"fixed\";\n                this.spacer = crel(\"div\", { class: prefix + \"-spacer\", style: `height: ${menuRect.height}px` });\n                parent.insertBefore(this.spacer, this.menu);\n            }\n        }\n    }\n    destroy() {\n        if (this.wrapper.parentNode)\n            this.wrapper.parentNode.replaceChild(this.editorView.dom, this.wrapper);\n    }\n}\n// Not precise, but close enough\nfunction selectionIsInverted(selection) {\n    if (selection.anchorNode == selection.focusNode)\n        return selection.anchorOffset > selection.focusOffset;\n    return selection.anchorNode.compareDocumentPosition(selection.focusNode) == Node.DOCUMENT_POSITION_FOLLOWING;\n}\nfunction findWrappingScrollable(node) {\n    for (let cur = node.parentNode; cur; cur = cur.parentNode)\n        if (cur.scrollHeight > cur.clientHeight)\n            return cur;\n}\nfunction getAllWrapping(node) {\n    let res = [node.ownerDocument.defaultView || window];\n    for (let cur = node.parentNode; cur; cur = cur.parentNode)\n        res.push(cur);\n    return res;\n}\n\nexport { Dropdown, DropdownSubmenu, MenuItem, blockTypeItem, icons, joinUpItem, liftItem, menuBar, redoItem, renderGrouped, selectParentNodeItem, undoItem, wrapItem };\n", "import { Plugin } from 'prosemirror-state';\nimport { findWrapping, canJoin } from 'prosemirror-transform';\n\n/**\nInput rules are regular expressions describing a piece of text\nthat, when typed, causes something to happen. This might be\nchanging two dashes into an emdash, wrapping a paragraph starting\nwith `\"> \"` into a blockquote, or something entirely different.\n*/\nclass InputRule {\n    // :: (RegExp, union<string, (state: EditorState, match: [string], start: number, end: number) → ?Transaction>)\n    /**\n    Create an input rule. The rule applies when the user typed\n    something and the text directly in front of the cursor matches\n    `match`, which should end with `$`.\n    \n    The `handler` can be a string, in which case the matched text, or\n    the first matched group in the regexp, is replaced by that\n    string.\n    \n    Or a it can be a function, which will be called with the match\n    array produced by\n    [`RegExp.exec`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec),\n    as well as the start and end of the matched range, and which can\n    return a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) that describes the\n    rule's effect, or null to indicate the input was not handled.\n    */\n    constructor(\n    /**\n    @internal\n    */\n    match, handler, options = {}) {\n        this.match = match;\n        this.match = match;\n        this.handler = typeof handler == \"string\" ? stringHandler(handler) : handler;\n        this.undoable = options.undoable !== false;\n        this.inCode = options.inCode || false;\n    }\n}\nfunction stringHandler(string) {\n    return function (state, match, start, end) {\n        let insert = string;\n        if (match[1]) {\n            let offset = match[0].lastIndexOf(match[1]);\n            insert += match[0].slice(offset + match[1].length);\n            start += offset;\n            let cutOff = start - end;\n            if (cutOff > 0) {\n                insert = match[0].slice(offset - cutOff, offset) + insert;\n                start = end;\n            }\n        }\n        return state.tr.insertText(insert, start, end);\n    };\n}\nconst MAX_MATCH = 500;\n/**\nCreate an input rules plugin. When enabled, it will cause text\ninput that matches any of the given rules to trigger the rule's\naction.\n*/\nfunction inputRules({ rules }) {\n    let plugin = new Plugin({\n        state: {\n            init() { return null; },\n            apply(tr, prev) {\n                let stored = tr.getMeta(this);\n                if (stored)\n                    return stored;\n                return tr.selectionSet || tr.docChanged ? null : prev;\n            }\n        },\n        props: {\n            handleTextInput(view, from, to, text) {\n                return run(view, from, to, text, rules, plugin);\n            },\n            handleDOMEvents: {\n                compositionend: (view) => {\n                    setTimeout(() => {\n                        let { $cursor } = view.state.selection;\n                        if ($cursor)\n                            run(view, $cursor.pos, $cursor.pos, \"\", rules, plugin);\n                    });\n                }\n            }\n        },\n        isInputRules: true\n    });\n    return plugin;\n}\nfunction run(view, from, to, text, rules, plugin) {\n    if (view.composing)\n        return false;\n    let state = view.state, $from = state.doc.resolve(from);\n    let textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - MAX_MATCH), $from.parentOffset, null, \"\\ufffc\") + text;\n    for (let i = 0; i < rules.length; i++) {\n        let rule = rules[i];\n        if ($from.parent.type.spec.code) {\n            if (!rule.inCode)\n                continue;\n        }\n        else if (rule.inCode === \"only\") {\n            continue;\n        }\n        let match = rule.match.exec(textBefore);\n        let tr = match && rule.handler(state, match, from - (match[0].length - text.length), to);\n        if (!tr)\n            continue;\n        if (rule.undoable)\n            tr.setMeta(plugin, { transform: tr, from, to, text });\n        view.dispatch(tr);\n        return true;\n    }\n    return false;\n}\n/**\nThis is a command that will undo an input rule, if applying such a\nrule was the last thing that the user did.\n*/\nconst undoInputRule = (state, dispatch) => {\n    let plugins = state.plugins;\n    for (let i = 0; i < plugins.length; i++) {\n        let plugin = plugins[i], undoable;\n        if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n            if (dispatch) {\n                let tr = state.tr, toUndo = undoable.transform;\n                for (let j = toUndo.steps.length - 1; j >= 0; j--)\n                    tr.step(toUndo.steps[j].invert(toUndo.docs[j]));\n                if (undoable.text) {\n                    let marks = tr.doc.resolve(undoable.from).marks();\n                    tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));\n                }\n                else {\n                    tr.delete(undoable.from, undoable.to);\n                }\n                dispatch(tr);\n            }\n            return true;\n        }\n    }\n    return false;\n};\n\n/**\nConverts double dashes to an emdash.\n*/\nconst emDash = new InputRule(/--$/, \"—\");\n/**\nConverts three dots to an ellipsis character.\n*/\nconst ellipsis = new InputRule(/\\.\\.\\.$/, \"…\");\n/**\n“Smart” opening double quotes.\n*/\nconst openDoubleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(\")$/, \"“\");\n/**\n“Smart” closing double quotes.\n*/\nconst closeDoubleQuote = new InputRule(/\"$/, \"”\");\n/**\n“Smart” opening single quotes.\n*/\nconst openSingleQuote = new InputRule(/(?:^|[\\s\\{\\[\\(\\<'\"\\u2018\\u201C])(')$/, \"‘\");\n/**\n“Smart” closing single quotes.\n*/\nconst closeSingleQuote = new InputRule(/'$/, \"’\");\n/**\nSmart-quote related input rules.\n*/\nconst smartQuotes = [openDoubleQuote, closeDoubleQuote, openSingleQuote, closeSingleQuote];\n\n/**\nBuild an input rule for automatically wrapping a textblock when a\ngiven string is typed. The `regexp` argument is\ndirectly passed through to the `InputRule` constructor. You'll\nprobably want the regexp to start with `^`, so that the pattern can\nonly occur at the start of a textblock.\n\n`nodeType` is the type of node to wrap in. If it needs attributes,\nyou can either pass them directly, or pass a function that will\ncompute them from the regular expression match.\n\nBy default, if there's a node with the same type above the newly\nwrapped node, the rule will try to [join](https://prosemirror.net/docs/ref/#transform.Transform.join) those\ntwo nodes. You can pass a join predicate, which takes a regular\nexpression match and the node before the wrapped node, and can\nreturn a boolean to indicate whether a join should happen.\n*/\nfunction wrappingInputRule(regexp, nodeType, getAttrs = null, joinPredicate) {\n    return new InputRule(regexp, (state, match, start, end) => {\n        let attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\n        let tr = state.tr.delete(start, end);\n        let $start = tr.doc.resolve(start), range = $start.blockRange(), wrapping = range && findWrapping(range, nodeType, attrs);\n        if (!wrapping)\n            return null;\n        tr.wrap(range, wrapping);\n        let before = tr.doc.resolve(start - 1).nodeBefore;\n        if (before && before.type == nodeType && canJoin(tr.doc, start - 1) &&\n            (!joinPredicate || joinPredicate(match, before)))\n            tr.join(start - 1);\n        return tr;\n    });\n}\n/**\nBuild an input rule that changes the type of a textblock when the\nmatched text is typed into it. You'll usually want to start your\nregexp with `^` to that it is only matched at the start of a\ntextblock. The optional `getAttrs` parameter can be used to compute\nthe new node's attributes, and works the same as in the\n`wrappingInputRule` function.\n*/\nfunction textblockTypeInputRule(regexp, nodeType, getAttrs = null) {\n    return new InputRule(regexp, (state, match, start, end) => {\n        let $start = state.doc.resolve(start);\n        let attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;\n        if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType))\n            return null;\n        return state.tr\n            .delete(start, end)\n            .setBlockType(start, start, nodeType, attrs);\n    });\n}\n\nexport { InputRule, closeDoubleQuote, closeSingleQuote, ellipsis, emDash, inputRules, openDoubleQuote, openSingleQuote, smartQuotes, textblockTypeInputRule, undoInputRule, wrappingInputRule };\n", "import { keymap } from 'prosemirror-keymap';\nimport { undo, redo, history } from 'prosemirror-history';\nimport { toggleMark, wrapIn, chainCommands, exitCode, setBlockType, joinUp, joinDown, lift, selectParentNode, baseKeymap } from 'prosemirror-commands';\nimport { NodeSelection, Plugin } from 'prosemirror-state';\nimport { dropCursor } from 'prosemirror-dropcursor';\nimport { gapCursor } from 'prosemirror-gapcursor';\nimport { icons, wrapItem, blockTypeItem, MenuItem, Dropdown, DropdownSubmenu, joinUpItem, liftItem, selectParentNodeItem, undoItem, redoItem, menuBar } from 'prosemirror-menu';\nimport { wrapInList, splitListItem, liftListItem, sinkListItem } from 'prosemirror-schema-list';\nimport { undoInputRule, smartQuotes, ellipsis, emDash, inputRules, wrappingInputRule, textblockTypeInputRule } from 'prosemirror-inputrules';\n\nconst prefix = \"ProseMirror-prompt\";\nfunction openPrompt(options) {\n    let wrapper = document.body.appendChild(document.createElement(\"div\"));\n    wrapper.className = prefix;\n    let mouseOutside = (e) => { if (!wrapper.contains(e.target))\n        close(); };\n    setTimeout(() => window.addEventListener(\"mousedown\", mouseOutside), 50);\n    let close = () => {\n        window.removeEventListener(\"mousedown\", mouseOutside);\n        if (wrapper.parentNode)\n            wrapper.parentNode.removeChild(wrapper);\n    };\n    let domFields = [];\n    for (let name in options.fields)\n        domFields.push(options.fields[name].render());\n    let submitButton = document.createElement(\"button\");\n    submitButton.type = \"submit\";\n    submitButton.className = prefix + \"-submit\";\n    submitButton.textContent = \"OK\";\n    let cancelButton = document.createElement(\"button\");\n    cancelButton.type = \"button\";\n    cancelButton.className = prefix + \"-cancel\";\n    cancelButton.textContent = \"Cancel\";\n    cancelButton.addEventListener(\"click\", close);\n    let form = wrapper.appendChild(document.createElement(\"form\"));\n    if (options.title)\n        form.appendChild(document.createElement(\"h5\")).textContent = options.title;\n    domFields.forEach(field => {\n        form.appendChild(document.createElement(\"div\")).appendChild(field);\n    });\n    let buttons = form.appendChild(document.createElement(\"div\"));\n    buttons.className = prefix + \"-buttons\";\n    buttons.appendChild(submitButton);\n    buttons.appendChild(document.createTextNode(\" \"));\n    buttons.appendChild(cancelButton);\n    let box = wrapper.getBoundingClientRect();\n    wrapper.style.top = ((window.innerHeight - box.height) / 2) + \"px\";\n    wrapper.style.left = ((window.innerWidth - box.width) / 2) + \"px\";\n    let submit = () => {\n        let params = getValues(options.fields, domFields);\n        if (params) {\n            close();\n            options.callback(params);\n        }\n    };\n    form.addEventListener(\"submit\", e => {\n        e.preventDefault();\n        submit();\n    });\n    form.addEventListener(\"keydown\", e => {\n        if (e.keyCode == 27) {\n            e.preventDefault();\n            close();\n        }\n        else if (e.keyCode == 13 && !(e.ctrlKey || e.metaKey || e.shiftKey)) {\n            e.preventDefault();\n            submit();\n        }\n        else if (e.keyCode == 9) {\n            window.setTimeout(() => {\n                if (!wrapper.contains(document.activeElement))\n                    close();\n            }, 500);\n        }\n    });\n    let input = form.elements[0];\n    if (input)\n        input.focus();\n}\nfunction getValues(fields, domFields) {\n    let result = Object.create(null), i = 0;\n    for (let name in fields) {\n        let field = fields[name], dom = domFields[i++];\n        let value = field.read(dom), bad = field.validate(value);\n        if (bad) {\n            reportInvalid(dom, bad);\n            return null;\n        }\n        result[name] = field.clean(value);\n    }\n    return result;\n}\nfunction reportInvalid(dom, message) {\n    // FIXME this is awful and needs a lot more work\n    let parent = dom.parentNode;\n    let msg = parent.appendChild(document.createElement(\"div\"));\n    msg.style.left = (dom.offsetLeft + dom.offsetWidth + 2) + \"px\";\n    msg.style.top = (dom.offsetTop - 5) + \"px\";\n    msg.className = \"ProseMirror-invalid\";\n    msg.textContent = message;\n    setTimeout(() => parent.removeChild(msg), 1500);\n}\n/**\nThe type of field that `openPrompt` expects to be passed to it.\n*/\nclass Field {\n    /**\n    Create a field with the given options. Options support by all\n    field types are:\n    */\n    constructor(\n    /**\n    @internal\n    */\n    options) {\n        this.options = options;\n    }\n    /**\n    Read the field's value from its DOM node.\n    */\n    read(dom) { return dom.value; }\n    /**\n    A field-type-specific validation function.\n    */\n    validateType(value) { return null; }\n    /**\n    @internal\n    */\n    validate(value) {\n        if (!value && this.options.required)\n            return \"Required field\";\n        return this.validateType(value) || (this.options.validate ? this.options.validate(value) : null);\n    }\n    clean(value) {\n        return this.options.clean ? this.options.clean(value) : value;\n    }\n}\n/**\nA field class for single-line text fields.\n*/\nclass TextField extends Field {\n    render() {\n        let input = document.createElement(\"input\");\n        input.type = \"text\";\n        input.placeholder = this.options.label;\n        input.value = this.options.value || \"\";\n        input.autocomplete = \"off\";\n        return input;\n    }\n}\n\n// Helpers to create specific types of items\nfunction canInsert(state, nodeType) {\n    let $from = state.selection.$from;\n    for (let d = $from.depth; d >= 0; d--) {\n        let index = $from.index(d);\n        if ($from.node(d).canReplaceWith(index, index, nodeType))\n            return true;\n    }\n    return false;\n}\nfunction insertImageItem(nodeType) {\n    return new MenuItem({\n        title: \"Insert image\",\n        label: \"Image\",\n        enable(state) { return canInsert(state, nodeType); },\n        run(state, _, view) {\n            let { from, to } = state.selection, attrs = null;\n            if (state.selection instanceof NodeSelection && state.selection.node.type == nodeType)\n                attrs = state.selection.node.attrs;\n            openPrompt({\n                title: \"Insert image\",\n                fields: {\n                    src: new TextField({ label: \"Location\", required: true, value: attrs && attrs.src }),\n                    title: new TextField({ label: \"Title\", value: attrs && attrs.title }),\n                    alt: new TextField({ label: \"Description\",\n                        value: attrs ? attrs.alt : state.doc.textBetween(from, to, \" \") })\n                },\n                callback(attrs) {\n                    view.dispatch(view.state.tr.replaceSelectionWith(nodeType.createAndFill(attrs)));\n                    view.focus();\n                }\n            });\n        }\n    });\n}\nfunction cmdItem(cmd, options) {\n    let passedOptions = {\n        label: options.title,\n        run: cmd\n    };\n    for (let prop in options)\n        passedOptions[prop] = options[prop];\n    if (!options.enable && !options.select)\n        passedOptions[options.enable ? \"enable\" : \"select\"] = state => cmd(state);\n    return new MenuItem(passedOptions);\n}\nfunction markActive(state, type) {\n    let { from, $from, to, empty } = state.selection;\n    if (empty)\n        return !!type.isInSet(state.storedMarks || $from.marks());\n    else\n        return state.doc.rangeHasMark(from, to, type);\n}\nfunction markItem(markType, options) {\n    let passedOptions = {\n        active(state) { return markActive(state, markType); }\n    };\n    for (let prop in options)\n        passedOptions[prop] = options[prop];\n    return cmdItem(toggleMark(markType), passedOptions);\n}\nfunction linkItem(markType) {\n    return new MenuItem({\n        title: \"Add or remove link\",\n        icon: icons.link,\n        active(state) { return markActive(state, markType); },\n        enable(state) { return !state.selection.empty; },\n        run(state, dispatch, view) {\n            if (markActive(state, markType)) {\n                toggleMark(markType)(state, dispatch);\n                return true;\n            }\n            openPrompt({\n                title: \"Create a link\",\n                fields: {\n                    href: new TextField({\n                        label: \"Link target\",\n                        required: true\n                    }),\n                    title: new TextField({ label: \"Title\" })\n                },\n                callback(attrs) {\n                    toggleMark(markType, attrs)(view.state, view.dispatch);\n                    view.focus();\n                }\n            });\n        }\n    });\n}\nfunction wrapListItem(nodeType, options) {\n    return cmdItem(wrapInList(nodeType, options.attrs), options);\n}\n/**\nGiven a schema, look for default mark and node types in it and\nreturn an object with relevant menu items relating to those marks.\n*/\nfunction buildMenuItems(schema) {\n    let r = {};\n    let mark;\n    if (mark = schema.marks.strong)\n        r.toggleStrong = markItem(mark, { title: \"Toggle strong style\", icon: icons.strong });\n    if (mark = schema.marks.em)\n        r.toggleEm = markItem(mark, { title: \"Toggle emphasis\", icon: icons.em });\n    if (mark = schema.marks.code)\n        r.toggleCode = markItem(mark, { title: \"Toggle code font\", icon: icons.code });\n    if (mark = schema.marks.link)\n        r.toggleLink = linkItem(mark);\n    let node;\n    if (node = schema.nodes.image)\n        r.insertImage = insertImageItem(node);\n    if (node = schema.nodes.bullet_list)\n        r.wrapBulletList = wrapListItem(node, {\n            title: \"Wrap in bullet list\",\n            icon: icons.bulletList\n        });\n    if (node = schema.nodes.ordered_list)\n        r.wrapOrderedList = wrapListItem(node, {\n            title: \"Wrap in ordered list\",\n            icon: icons.orderedList\n        });\n    if (node = schema.nodes.blockquote)\n        r.wrapBlockQuote = wrapItem(node, {\n            title: \"Wrap in block quote\",\n            icon: icons.blockquote\n        });\n    if (node = schema.nodes.paragraph)\n        r.makeParagraph = blockTypeItem(node, {\n            title: \"Change to paragraph\",\n            label: \"Plain\"\n        });\n    if (node = schema.nodes.code_block)\n        r.makeCodeBlock = blockTypeItem(node, {\n            title: \"Change to code block\",\n            label: \"Code\"\n        });\n    if (node = schema.nodes.heading)\n        for (let i = 1; i <= 10; i++)\n            r[\"makeHead\" + i] = blockTypeItem(node, {\n                title: \"Change to heading \" + i,\n                label: \"Level \" + i,\n                attrs: { level: i }\n            });\n    if (node = schema.nodes.horizontal_rule) {\n        let hr = node;\n        r.insertHorizontalRule = new MenuItem({\n            title: \"Insert horizontal rule\",\n            label: \"Horizontal rule\",\n            enable(state) { return canInsert(state, hr); },\n            run(state, dispatch) { dispatch(state.tr.replaceSelectionWith(hr.create())); }\n        });\n    }\n    let cut = (arr) => arr.filter(x => x);\n    r.insertMenu = new Dropdown(cut([r.insertImage, r.insertHorizontalRule]), { label: \"Insert\" });\n    r.typeMenu = new Dropdown(cut([r.makeParagraph, r.makeCodeBlock, r.makeHead1 && new DropdownSubmenu(cut([\n            r.makeHead1, r.makeHead2, r.makeHead3, r.makeHead4, r.makeHead5, r.makeHead6\n        ]), { label: \"Heading\" })]), { label: \"Type...\" });\n    r.inlineMenu = [cut([r.toggleStrong, r.toggleEm, r.toggleCode, r.toggleLink])];\n    r.blockMenu = [cut([r.wrapBulletList, r.wrapOrderedList, r.wrapBlockQuote, joinUpItem,\n            liftItem, selectParentNodeItem])];\n    r.fullMenu = r.inlineMenu.concat([[r.insertMenu, r.typeMenu]], [[undoItem, redoItem]], r.blockMenu);\n    return r;\n}\n\nconst mac = typeof navigator != \"undefined\" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;\n/**\nInspect the given schema looking for marks and nodes from the\nbasic schema, and if found, add key bindings related to them.\nThis will add:\n\n* **Mod-b** for toggling [strong](https://prosemirror.net/docs/ref/#schema-basic.StrongMark)\n* **Mod-i** for toggling [emphasis](https://prosemirror.net/docs/ref/#schema-basic.EmMark)\n* **Mod-`** for toggling [code font](https://prosemirror.net/docs/ref/#schema-basic.CodeMark)\n* **Ctrl-Shift-0** for making the current textblock a paragraph\n* **Ctrl-Shift-1** to **Ctrl-Shift-Digit6** for making the current\n  textblock a heading of the corresponding level\n* **Ctrl-Shift-Backslash** to make the current textblock a code block\n* **Ctrl-Shift-8** to wrap the selection in an ordered list\n* **Ctrl-Shift-9** to wrap the selection in a bullet list\n* **Ctrl->** to wrap the selection in a block quote\n* **Enter** to split a non-empty textblock in a list item while at\n  the same time splitting the list item\n* **Mod-Enter** to insert a hard break\n* **Mod-_** to insert a horizontal rule\n* **Backspace** to undo an input rule\n* **Alt-ArrowUp** to `joinUp`\n* **Alt-ArrowDown** to `joinDown`\n* **Mod-BracketLeft** to `lift`\n* **Escape** to `selectParentNode`\n\nYou can suppress or map these bindings by passing a `mapKeys`\nargument, which maps key names (say `\"Mod-B\"` to either `false`, to\nremove the binding, or a new key name string.\n*/\nfunction buildKeymap(schema, mapKeys) {\n    let keys = {}, type;\n    function bind(key, cmd) {\n        if (mapKeys) {\n            let mapped = mapKeys[key];\n            if (mapped === false)\n                return;\n            if (mapped)\n                key = mapped;\n        }\n        keys[key] = cmd;\n    }\n    bind(\"Mod-z\", undo);\n    bind(\"Shift-Mod-z\", redo);\n    bind(\"Backspace\", undoInputRule);\n    if (!mac)\n        bind(\"Mod-y\", redo);\n    bind(\"Alt-ArrowUp\", joinUp);\n    bind(\"Alt-ArrowDown\", joinDown);\n    bind(\"Mod-BracketLeft\", lift);\n    bind(\"Escape\", selectParentNode);\n    if (type = schema.marks.strong) {\n        bind(\"Mod-b\", toggleMark(type));\n        bind(\"Mod-B\", toggleMark(type));\n    }\n    if (type = schema.marks.em) {\n        bind(\"Mod-i\", toggleMark(type));\n        bind(\"Mod-I\", toggleMark(type));\n    }\n    if (type = schema.marks.code)\n        bind(\"Mod-`\", toggleMark(type));\n    if (type = schema.nodes.bullet_list)\n        bind(\"Shift-Ctrl-8\", wrapInList(type));\n    if (type = schema.nodes.ordered_list)\n        bind(\"Shift-Ctrl-9\", wrapInList(type));\n    if (type = schema.nodes.blockquote)\n        bind(\"Ctrl->\", wrapIn(type));\n    if (type = schema.nodes.hard_break) {\n        let br = type, cmd = chainCommands(exitCode, (state, dispatch) => {\n            if (dispatch)\n                dispatch(state.tr.replaceSelectionWith(br.create()).scrollIntoView());\n            return true;\n        });\n        bind(\"Mod-Enter\", cmd);\n        bind(\"Shift-Enter\", cmd);\n        if (mac)\n            bind(\"Ctrl-Enter\", cmd);\n    }\n    if (type = schema.nodes.list_item) {\n        bind(\"Enter\", splitListItem(type));\n        bind(\"Mod-[\", liftListItem(type));\n        bind(\"Mod-]\", sinkListItem(type));\n    }\n    if (type = schema.nodes.paragraph)\n        bind(\"Shift-Ctrl-0\", setBlockType(type));\n    if (type = schema.nodes.code_block)\n        bind(\"Shift-Ctrl-\\\\\", setBlockType(type));\n    if (type = schema.nodes.heading)\n        for (let i = 1; i <= 6; i++)\n            bind(\"Shift-Ctrl-\" + i, setBlockType(type, { level: i }));\n    if (type = schema.nodes.horizontal_rule) {\n        let hr = type;\n        bind(\"Mod-_\", (state, dispatch) => {\n            if (dispatch)\n                dispatch(state.tr.replaceSelectionWith(hr.create()).scrollIntoView());\n            return true;\n        });\n    }\n    return keys;\n}\n\n/**\nGiven a blockquote node type, returns an input rule that turns `\"> \"`\nat the start of a textblock into a blockquote.\n*/\nfunction blockQuoteRule(nodeType) {\n    return wrappingInputRule(/^\\s*>\\s$/, nodeType);\n}\n/**\nGiven a list node type, returns an input rule that turns a number\nfollowed by a dot at the start of a textblock into an ordered list.\n*/\nfunction orderedListRule(nodeType) {\n    return wrappingInputRule(/^(\\d+)\\.\\s$/, nodeType, match => ({ order: +match[1] }), (match, node) => node.childCount + node.attrs.order == +match[1]);\n}\n/**\nGiven a list node type, returns an input rule that turns a bullet\n(dash, plush, or asterisk) at the start of a textblock into a\nbullet list.\n*/\nfunction bulletListRule(nodeType) {\n    return wrappingInputRule(/^\\s*([-+*])\\s$/, nodeType);\n}\n/**\nGiven a code block node type, returns an input rule that turns a\ntextblock starting with three backticks into a code block.\n*/\nfunction codeBlockRule(nodeType) {\n    return textblockTypeInputRule(/^```$/, nodeType);\n}\n/**\nGiven a node type and a maximum level, creates an input rule that\nturns up to that number of `#` characters followed by a space at\nthe start of a textblock into a heading whose level corresponds to\nthe number of `#` signs.\n*/\nfunction headingRule(nodeType, maxLevel) {\n    return textblockTypeInputRule(new RegExp(\"^(#{1,\" + maxLevel + \"})\\\\s$\"), nodeType, match => ({ level: match[1].length }));\n}\n/**\nA set of input rules for creating the basic block quotes, lists,\ncode blocks, and heading.\n*/\nfunction buildInputRules(schema) {\n    let rules = smartQuotes.concat(ellipsis, emDash), type;\n    if (type = schema.nodes.blockquote)\n        rules.push(blockQuoteRule(type));\n    if (type = schema.nodes.ordered_list)\n        rules.push(orderedListRule(type));\n    if (type = schema.nodes.bullet_list)\n        rules.push(bulletListRule(type));\n    if (type = schema.nodes.code_block)\n        rules.push(codeBlockRule(type));\n    if (type = schema.nodes.heading)\n        rules.push(headingRule(type, 6));\n    return inputRules({ rules });\n}\n\n/**\nCreate an array of plugins pre-configured for the given schema.\nThe resulting array will include the following plugins:\n\n * Input rules for smart quotes and creating the block types in the\n   schema using markdown conventions (say `\"> \"` to create a\n   blockquote)\n\n * A keymap that defines keys to create and manipulate the nodes in the\n   schema\n\n * A keymap binding the default keys provided by the\n   prosemirror-commands module\n\n * The undo history plugin\n\n * The drop cursor plugin\n\n * The gap cursor plugin\n\n * A custom plugin that adds a `menuContent` prop for the\n   prosemirror-menu wrapper, and a CSS class that enables the\n   additional styling defined in `style/style.css` in this package\n\nProbably only useful for quickly setting up a passable\neditor—you'll need more control over your settings in most\nreal-world situations.\n*/\nfunction exampleSetup(options) {\n    let plugins = [\n        buildInputRules(options.schema),\n        keymap(buildKeymap(options.schema, options.mapKeys)),\n        keymap(baseKeymap),\n        dropCursor(),\n        gapCursor()\n    ];\n    if (options.menuBar !== false)\n        plugins.push(menuBar({ floating: options.floatingMenu !== false,\n            content: options.menuContent || buildMenuItems(options.schema).fullMenu }));\n    if (options.history !== false)\n        plugins.push(history());\n    return plugins.concat(new Plugin({\n        props: {\n            attributes: { class: \"ProseMirror-example-setup-style\" }\n        }\n    }));\n}\n\nexport { buildInputRules, buildKeymap, buildMenuItems, exampleSetup };\n"],
  "mappings": "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",
  "names": ["mac", "shift", "map", "RopeSequence", "from", "Leaf", "Append", "appendInner", "map", "from", "history", "redo", "redo", "from", "add", "mac", "rect", "update", "from", "prefix", "from", "attrs", "mac"]
}
